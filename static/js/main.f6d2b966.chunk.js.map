{"version":3,"sources":["rain/constants/item.ts","rain/constants/matches.ts","MintButton.tsx","rain/constants/programIds.ts","Home.tsx","rain/constants/namespace.ts","rain/constants/player.ts","rain/utils/ata.ts","rain/state/matches.ts","rain/utils/connection.ts","rain/contract/matches.ts","rain/utils/pda.ts","App.tsx","reportWebVitals.ts","index.tsx","connection.tsx"],"names":["PREFIX","MARKER","CTAButton","styled","Button","NAMESPACE_ID","web3","PublicKey","ITEM_ID","PLAYER_ID","MATCHES_ID","TOKEN_PROGRAM_ID","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID","TOKEN_METADATA_PROGRAM_ID","someDecs2","fanout","anchor","WalletContainer","process","toString","div","Wallet","ul","ConnectButton","WalletMultiButton","NFT","Paper","MainContainer","a","MintContainer","DesContainer","Price","Chip","Image","img","first","LinearProgress","Home","props","useWallet","sendTransaction","useState","Date","getTime","balance","setBalance","isActive","price","priceLabel","whitelistPrice","whitelistEnabled","whitelistTokenBalance","connection","useConnection","wallet","open","message","severity","undefined","alertState","setAlertState","anchorWallet","rpcHost","useMemo","publicKey","signAllTransactions","signTransaction","useEffect","setTimeout","console","log","mint","mintPublicKey","getTokenAccountsByOwner","tokAccs","bal","value","i","getTokenAccountBalance","pubkey","eh1","eh2","uiAmount","setInterval","shares","setShares","connection2","Connection","e","preventDefault","target","provider","preflightCommitment","fanoutSdk","FanoutClient","ixes","acount","acount2","Object","keys","der","distributeTokenMemberInstructions","distributeForMint","fanoutMint","membershipMint","member","payer","ix","instructions","bla","push","length","sendInstructions","fetch","Fanout","blarg","toBase58","parseFloat","stakeTokenMemberInstructions","ixs","unstakeTokenMember","elevation","label","src","alt","href","onClick","style","color","fontSize","backgroundColor","type","onInput","autoHideDuration","onClose","createAssociatedTokenAccountInstruction","associatedTokenAddress","walletAddress","splTokenMintAddress","isSigner","isWritable","SystemProgram","programId","SYSVAR_RENT_PUBKEY","TransactionInstruction","data","Buffer","from","MatchState","TokenTransferType","TokenType","clusterApiUrl","transformTokenValidations","args","tokenEntryValidation","map","r","newRFilter","filter","forEach","k","y","validation","key","code","BN","MatchWrapper","program","object","this","MatchesInstruction","id","getMatch","winOracle","match","methods","createMatch","accounts","matchInstance","systemProgram","rent","instruction","signers","additionalArgs","tfer","tokenDelta","getMatchTokenAccountEscrow","tokenAccountEscrow","destinationTokenAccount","to","getAccountInfo","info","owner","equals","destinationTokenOwner","getAtaForMint","exists","unshift","disburseTokensByOracle","tokenMint","originalSender","tokenProgram","_args","drainMatch","authority","receiver","getOracle","seed","oracle","drainOracle","updateMatch","leaveMatch","sourceTokenAccount","transferAuthority","tokenTransferAuthority","Keypair","generate","Token","createApproveInstruction","amount","toNumber","joinMatch","sourceType","Any","Item","getItemPDA","index","getPlayerPDA","validationProgram","sourceItemOrPlayerPda","createRevokeInstruction","updateMatchFromOracle","clock","SYSVAR_CLOCK_PUBKEY","tokenTransfers","t","createOrUpdateOracle","MatchesProgram","matchPda","account","oracleAcct","coder","decode","oracleInstance","sendTransactionWithRetry","findProgramAddress","toBuffer","MATCHES_PREFIX","tokenOwner","ITEM_PREFIX","PLAYER_PREFIX","require","network","theme","createTheme","palette","overrides","MuiButtonBase","root","justifyContent","MuiButton","textTransform","padding","startIcon","marginRight","endIcon","marginLeft","App","endpoint","wallets","getPhantomWallet","getSlopeWallet","getSolflareWallet","getSolflareWebWallet","getSolletWallet","getSolletExtensionWallet","getSolongWallet","getLedgerWallet","getSafePalWallet","ThemeProvider","ConnectionProvider","WalletProvider","autoConnect","txTimeout","DEFAULT_TIMEOUT","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById","SequenceType","commitment","includesFeePayer","block","beforeSend","WalletNotConnectedError","transaction","Transaction","add","getRecentBlockhash","recentBlockhash","blockhash","setSigners","s","partialSign","sendSignedTransaction","signedTransaction","txid","slot","getUnixTs","timeout","rawTransaction","serialize","startTime","sendRawTransaction","skipPreflight","done","sleep","awaitTransactionSignatureConfirmation","confirmation","Error","err","error","simulateResult","simulateTransaction","logs","line","startsWith","slice","JSON","stringify","_recentBlockhash","_disableBlockhashCaching","signData","serializeMessage","wireTransaction","_serialize","encodedTransaction","encoding","_rpcRequest","res","result","queryStatus","status","confirmations","subId","Promise","resolve","reject","onSignature","context","getSignatureStatuses","signatureStatuses","_signatureSubscriptions","removeSignatureListener","ms"],"mappings":"gIAAA,oEAAO,IAAMA,EAAiB,OACjBC,EAAiB,U,iCCD9B,kCAAO,IAAMD,EAAS,W,4GCOTE,G,MAAYC,YAAOC,IAAPD,CAAH,iN,gCCPtB,0PAEaE,EAAe,IAAIC,OAAKC,UACnC,+CAGWC,EAAU,IAAIF,OAAKC,UAC9B,+CAGWE,EAAY,IAAIH,OAAKC,UAChC,+CAGWG,EAAa,IAAIJ,OAAKC,UACjC,+CAOWI,GAJmB,IAAIL,OAAKC,UACvC,+CAG8B,IAAID,OAAKC,UACvC,gDAGWK,EAA0C,IAAIN,OAAKC,UAC9D,gDAGWM,EAA4B,IAAIP,OAAKC,UAChD,gD,wTCHIO,EAAY,CAAC,6CAA+C,EAClE,+CAA+C,EAC/C,6CAA+C,EAC/C,+CAA+C,EAC/C,+CAA+C,EAC/C,4CAA8C,EAAG,4CAA8C,GAevFC,GAHkB,IAAIC,OAAYT,UACtC,+CAEa,IAAIA,YAAU,iDAMzBU,GAJUC,eAAsCC,WAI9BhB,IAAOiB,IAAV,sHAiCfC,GA1BelB,IAAOiB,IAAV,iyBA0BHjB,IAAOmB,GAAV,6EAMNC,EAAgBpB,YAAOqB,IAAPrB,CAAH,sIAObsB,EAAMtB,YAAOuB,IAAPvB,CAAH,iRA8DHwB,GArDOxB,YAAOuB,IAAPvB,CAAH,gNAYkBA,IAAOiB,IAAV,mjBAyBDjB,IAAOyB,EAAV,iXAgBCzB,IAAOiB,IAAV,mNAWbS,EAAgB1B,IAAOiB,IAAV,2HAQbU,EAAe3B,IAAOiB,IAAV,0GAOZW,EAAQ5B,YAAO6B,IAAP7B,CAAH,6KAQL8B,EAAQ9B,IAAO+B,IAAV,yIAgCPC,GAzByBhC,YAAOiC,IAAPjC,CAAH,uhBAyBd,GA2iBGkC,IA1iBF,SAACC,GACcC,cAAnBC,gBAAP,IACA,EAA0BC,oBAAiB,IAAIC,MAAOC,UAAY,GAAlE,mBACA,GADA,UAC8BF,mBAAS,IAAvC,mBAAOG,EAAP,KAAgBC,EAAhB,KACA,EAA8BJ,qBAA9B,mBAEA,GAFA,UAE0BA,mBAAiB,IAA3C,mBACE,GADF,UACoCA,oBAAS,IAA3C,mBACA,GADA,UACgCA,oBAAS,IAAzC,mBAAOK,EAAP,KACA,GADA,KACoDL,mBAAiB,KAArE,mBACA,GADA,UAC4CA,mBAAS,IAArD,mBACA,GADA,UAC0CA,mBAAS,IAAnD,mBACA,GADA,UAC4CA,mBAAS,IAArD,mBACA,IADA,UACkCA,oBAAS,IAA3C,qBACA,IADA,YAC8CA,oBAAS,IAAvD,qBACA,IADA,YAC0BA,mBAAS,OAAnC,qBAAOM,GAAP,MACA,IADA,MACoCN,mBAAiB,QAArD,qBAAOO,GAAP,MACA,IADA,MAC4CP,mBAAS,IAArD,qBAAOQ,GAAP,MACA,IADA,MACgDR,oBAAS,IAAzD,qBAAOS,GAAP,MACA,IADA,MACsCT,oBAAS,IAA/C,qBACA,IADA,YAC0DA,mBAAS,IAAnE,qBAAOU,GAAP,MACA,IADA,MAC8BV,oBAAS,IAAvC,qBACA,IADA,YAC8BA,sBAA9B,qBACA,IADA,YACkCA,oBAAS,IAA3C,qBACA,IADA,YACgCA,oBAAS,IAAzC,qBACA,IADA,YAC4BA,mBAAS,KAArC,qBAEIW,IAFJ,YAEmBC,cAAfD,YAEFE,GAASf,cAEX,GAAoCE,mBAAqB,CACrDc,MAAM,EACNC,QAAS,GACTC,cAAUC,IAHd,qBAAOC,GAAP,MAAmBC,GAAnB,MAMA,GAAwCnB,oBAAS,GAAjD,qBAIMoB,IAJN,YACevB,EAAMwB,QAGAC,mBAAQ,WACzB,GACKT,IACAA,GAAOU,WACPV,GAAOW,qBACPX,GAAOY,gBAKZ,MAAO,CACHF,UAAWV,GAAOU,UAClBC,oBAAqBX,GAAOW,oBAC5BC,gBAAiBZ,GAAOY,mBAE7B,CAACZ,MAmNJa,qBAAU,WACN,gCAAC,wFACON,IAEbO,WAAU,gCAAC,0GACHjC,EADG,wBAETA,GAAQ,EAFC,SAKNkC,QAAQC,IAAIT,GAAaG,UAAuB,CAACO,KAAKC,KALhD,SAMcpB,GAAWqB,wBAAwBZ,GAAaG,UAAuB,CAACO,KAAKC,KAN3F,OAMFE,EANE,OAOJC,EAAM,EAPF,wBAQAD,EAAQE,OARR,qDAQLC,EARK,+BAUMzB,GAAW0B,uBAAuBJ,EAAQE,MAAMC,GAAGE,QAVzD,QAUNC,EAVM,OAWNC,EAAMD,EAAIJ,MAAMM,UAAY,EACpCP,GAAMM,EAZQ,mDAedZ,QAAQC,IAAR,MAfc,QAiBZzB,EAAW8B,GAjBC,yEAyBZN,QAAQC,IAAR,MAzBY,QA6BXa,YAAW,gCAAC,sHAINd,QAAQC,IAAIT,GAAaG,UAAuB,CAACO,KAAKC,KAJhD,SAKcpB,GAAWqB,wBAAwBZ,GAAaG,UAAuB,CAACO,KAAKC,KAL3F,OAKFE,EALE,OAMJC,EAAM,EANF,wBAOAD,EAAQE,OAPR,qDAOLC,EAPK,8BASMzB,GAAW0B,uBAAuBJ,EAAQE,MAAMC,GAAGE,QATzD,QASNC,EATM,OAUNC,EAAMD,EAAIJ,MAAMM,UAAY,EACpCP,GAAMM,EAXQ,kDAcdZ,QAAQC,IAAR,MAdc,QAgBZzB,EAAW8B,GAhBC,yEAwBZN,QAAQC,IAAR,MAxBY,iEA4BX,OAzDU,kEA2DV,KA9DK,0CAAD,KAiED,CAACT,GAAcvB,EAAMc,aAU5B,IAAMoB,GAAgB,IAAIjE,YAAU,gDAChC,GAAsBkC,mBAAS,QAAnC,qBAAK2C,GAAL,MAAaC,GAAb,MAEIC,GAAc,IAAIC,aAAW,iCAAkC,aA1VhC,wDA4VnC,WAAwBC,GAAxB,2EACIA,EAAEC,iBACFpB,QAAQC,IAAIkB,EAAEE,OAAOd,OACrBS,GAAUG,EAAEE,OAAOd,OAHvB,4CA5VmC,8EAkWnC,0HACMtB,GADN,iBAGQqC,EAAW,IAAI3E,WAAgBoC,GAAYS,GAAc,CAC7D+B,oBAAqB,cAEvBC,EAAY,IAAIC,eACdR,GACAK,EAASrC,QAEPyC,EAAO,CAAC,IACRC,EAAS,EACTC,EAAU,EAZhB,MAcgBC,OAAOC,KAAKrF,GAd5B,gDAcSsF,EAdT,KAeEJ,IAfF,UAgBeH,EAAUQ,kCACvB,CAEEC,mBAAmB,EAEnBvF,OAAQA,EACRwF,WAAY,IAAIhG,YAAU6F,GAE1BI,eAAgBhC,GAEhBiC,OAAQnD,GAAOU,UAEf0C,MAAOpD,GAAOU,YA5BlB,QAgBI2C,EAhBJ,qBAgCgBA,EAAGC,cAhCnB,IAgCA,2BAASC,EAAuB,QAE9Bd,EAAKE,GAASa,KAAKD,GAlCrB,8BAoCIb,EAAS,IACXA,EAAS,EACTC,IACAF,EAAKe,KAAK,KAvCZ,mCA4CAzC,QAAQC,IAAIyB,EAAKgB,QACRlC,EAAI,EA7Cb,aA6CgBA,GAAKoB,GA7CrB,sBA8CMpB,KAAKkB,GA9CX,sBA+CMA,EAAKlB,GAAGkC,OAAS,GA/CvB,kCAgDiBlB,EAAUmB,iBAAV,YACXjB,EAAKlB,IAET,GAEAvB,GAAOU,WArDT,uBA6C8Ba,IA7C9B,6DAlWmC,8EA8ZnC,wHAEIvB,GAFJ,wBAMQqC,EAAW,IAAI3E,WAAgBoC,GAAYS,GAAc,CAC7D+B,oBAAqB,cAEvBC,EAAY,IAAIC,eACdR,GACAK,EAASrC,QAXb,SAakBuC,EAAUoB,MAAclG,EAAQmG,UAblD,cAaIC,EAbJ,OAcA9C,QAAQC,IAAR,UAAY6C,EAAMX,sBAAlB,aAAY,EAAsBY,YAClC/C,QAAQC,IAAR,UAAY6C,EAAMX,sBAAlB,aAAY,EAAsBY,YAClC/C,QAAQC,IAAR,UAAY6C,EAAMX,sBAAlB,aAAY,EAAsBY,YAClC/C,QAAQC,IAAR,UAAY6C,EAAMX,sBAAlB,aAAY,EAAsBY,YAClC/C,QAAQC,IAAR,UAAY6C,EAAMX,sBAAlB,aAAY,EAAsBY,YAClC/C,QAAQC,IAAR,UAAY6C,EAAMX,sBAAlB,aAAY,EAAsBY,YAClC/C,QAAQC,IAAR,UAAY6C,EAAMX,sBAAlB,aAAY,EAAsBY,YAClC/C,QAAQC,IAAR,UAAY6C,EAAMX,sBAAlB,aAAY,EAAsBY,YAClC/C,QAAQC,IAAM+C,WAAWjC,IAAX,SAAqB,GAAM,IAtBzC,UAuBiBS,EAAUyB,6BACrB,CAEIlC,OAAUiC,WAAWjC,IAAX,SAAqB,GAAM,GAErCrE,OAAQA,EACRyF,eAAgBhC,GAEhBiC,OAAQnD,GAAOU,UAEf0C,MAAOpD,GAAOU,YAjCxB,eAuBKuD,EAvBL,iBAmCmB1B,EAAUmB,iBACzBO,EAAIX,aACJ,GAEAtD,GAAOU,WAvCX,4DA9ZmC,8EAqdnC,oGAEMV,GAFN,uBAKQqC,EAAW,IAAI3E,WAAgBoC,GAAYS,GAAc,CAC7D+B,oBAAqB,cAEvBC,EAAY,IAAIC,eACdR,GACAK,EAASrC,QAVb,SAaQuC,EAAU2B,mBAAmB,CAEjCzG,OAAQA,EAER0F,OAAQnD,GAAOU,UAEf0C,MAAOpD,GAAOU,YAnBlB,4CArdmC,sBA8e/B,OACI,iCACI,eAACrC,EAAD,WACI,cAACV,EAAD,UACI,cAACI,EAAD,UACKiC,GACG,cAAC/B,EAAD,IACA,cAACA,EAAD,iCAGZ,uBACA,cAACM,EAAD,UACI,cAACC,EAAD,UACI,eAACL,EAAD,CAAKgG,UAAW,EAAhB,UAEI,gCAAK,cAAC1F,EAAD,CACD2F,MAAO5E,GAAYI,IAAqBC,GAAwB,EAAMF,GAAiB,IAAMD,GAAeD,GAAQ,IAAMC,KAAc,cAACf,EAAD,CACxI0F,IAAI,gBACJC,IAAI,mBACR,uBAEI,gCAChC,uBADgC,YAEtBhF,EAFsB,gCAEe,cAAC,IAAD,CAAMiF,KAAM,mFAAZ,iBAC/C,uBAHgC,wBAIX,uBAJW,IAIJ,uBAEpB,cAAC,IAAD,CAAWC,QAzgBgB,4CAygB3B,kCACR,uBACA,cAAC,IAAD,CAAQC,MAAO,CAACC,MAAM,QAASC,SAAU,QAASC,gBAAiB,QAASC,KAAK,OAAOC,QA3gBrD,6CA2gBwExD,MAAOQ,KAClH,uBAAM,uBAGN,cAAC,IAAD,CAAY0C,QA/gBuB,4CA+gBnC,mBACA,uBAEA,cAAC,IAAD,CAAYA,QAlhBuB,4CAkhBnC,yBACA,oCAOY,cAAC,IAAD,CACIvE,KAAMI,GAAWJ,KACjB8E,iBAAkB,IAClBC,QAAS,kBAAM1E,GAAc,2BAAID,IAAL,IAAiBJ,MAAM,MAHvD,SAKI,cAAC,IAAD,CACI+E,QAAS,kBAAM1E,GAAc,2BAAID,IAAL,IAAiBJ,MAAM,MACnDE,SAAUE,GAAWF,SAFzB,SAIKE,GAAWH,kB,yDCxwBhC,kCAAO,IAAMxD,EAAiB,a,iCCA9B,kCAAO,IAAMA,EAAiB,U,kCCA9B,0EAIO,SAASuI,EACdC,EACA9B,EACA+B,EACAC,GAEA,IAAMvC,EAAO,CACX,CACEpB,OAAQ2B,EACRiC,UAAU,EACVC,YAAY,GAEd,CACE7D,OAAQyD,EACRG,UAAU,EACVC,YAAY,GAEd,CACE7D,OAAQ0D,EACRE,UAAU,EACVC,YAAY,GAEd,CACE7D,OAAQ2D,EACRC,UAAU,EACVC,YAAY,GAEd,CACE7D,OAAQzE,OAAKuI,cAAcC,UAC3BH,UAAU,EACVC,YAAY,GAEd,CACE7D,OAAQpE,mBACRgI,UAAU,EACVC,YAAY,GAEd,CACE7D,OAAQzE,OAAKyI,mBACbJ,UAAU,EACVC,YAAY,IAGhB,OAAO,IAAItI,OAAK0I,uBAAuB,CACrC7C,OACA2C,UAAWlI,IACXqI,KAAMC,EAAOC,KAAK,S,+FCvBVC,EASAC,EAMAC,E,gHC7BHC,wBAAc,WAIdA,wBAAc,W,SDUXH,O,iBAAAA,I,6BAAAA,I,qBAAAA,I,yBAAAA,I,qBAAAA,I,8BAAAA,M,cASAC,O,mCAAAA,I,qCAAAA,I,oBAAAA,M,cAMAC,O,mBAAAA,I,eAAAA,I,cAAAA,M,0BEPL,SAASE,EAA0BC,GAGpCA,EAAKC,uBACPD,EAAKC,qBAAuBD,EAAKC,qBAAqBC,KAAI,SAACC,GACzD,IAAMC,EAAU,eAAQD,EAAEE,QAiB1B,OAhBA5D,OAAOC,KAAK0D,GAAYE,SAAQ,SAACC,GAC/B9D,OAAOC,KAAK0D,EAAWG,IAAID,SAAQ,SAACE,GACF,kBAArBJ,EAAWG,GAAGC,KACvBJ,EAAWG,GAAGC,GAAK,IAAI3J,OAAKC,UAAUsJ,EAAWG,GAAGC,WAK1DL,EAAEE,OAASD,EAEPD,EAAEM,YAC4B,kBAArBN,EAAEM,WAAWC,MACtBP,EAAEM,WAAWC,IAAM,IAAI7J,OAAKC,UAAUqJ,EAAEM,WAAWC,KACnDP,EAAEM,WAAWE,KAAO,IAAIC,KAAGT,EAAEM,WAAWE,OAGrCR,MAIN,IAAMU,EAAb,aAME,WAAYb,GAKR,yBAVJc,aAUG,OATHJ,SASG,OARHK,YAQG,OAPHvB,UAOG,EACDwB,KAAKF,QAAUd,EAAKc,QACpBE,KAAKN,IAAMV,EAAKU,IAChBM,KAAKD,OAASf,EAAKe,OACnBC,KAAKxB,KAAOQ,EAAKR,QAmHRyB,EAAb,WAIE,WAAYjB,GAAiD,yBAH7DkB,QAG4D,OAF5DJ,aAE4D,EAC1DE,KAAKE,GAAKlB,EAAKkB,GACfF,KAAKF,QAAUd,EAAKc,QANxB,gGASE,WACEd,GADF,uIAEc,GAFd,+BAGoB,GAHpB,SAKoCmB,YAASnB,EAAKoB,WALlD,0CAKSC,EALT,UAOEtB,EAA0BC,GAP5B,UAUYgB,KAAKF,QAAQQ,QAChBC,YAAYvB,GACZwB,SAAS,CACRC,cAAeJ,EACfpE,MAAQ+D,KAAKF,QAAQ5E,SAAsBrC,OAAOU,UAClDmH,cAAetC,gBAAcC,UAC7BsC,KAAM9K,OAAKyI,qBAEZsC,cAlBT,4CAoBa,GApBb,mBASIzE,aATJ,KAoBI0E,QApBJ,wDATF,4IAiCE,WACE7B,EACAwB,EACAM,GAHF,mHAKuBX,YAASK,EAASJ,WALzC,cAKQC,EALR,OAKqD,GAC7CU,EAAOD,EAAeE,WAN9B,SAQkDC,YAC9CT,EAASJ,UACTW,EAAKjH,KACLiH,EAAKrC,MAXT,0CAQSwC,EART,UAcMC,EAA0BJ,EAAKK,GAdrC,UAgBIpB,KAAKF,QAAQ5E,SACbvC,WAAW0I,eAAeF,GAjB9B,WAeQG,EAfR,OAmBQnF,EAAe,GAEhBmF,EAAKC,MAAMC,OAAOtL,KArBzB,wBAsBUuL,EAAwBN,EAtBlC,UAwBYO,YAAcX,EAAKjH,KAAMqH,GAxBrC,eAuBIA,EAvBJ,OAyBM,GAzBN,UA4BMnB,KAAKF,QAAQ5E,SACbvC,WAAW0I,eAAeF,GA7BhC,SA2BUQ,EA3BV,SA+ByC,GAAtBA,EAAOnD,KAAKlC,QACzBH,EAAayF,QACX9D,YACEqD,EACCnB,KAAKF,QAAQ5E,SAAsBrC,OAAOU,UAC3CkI,EACAV,EAAKjH,OArCf,oBA2CEqC,EA3CF,UA4CU6D,KAAKF,QAAQQ,QAChBuB,uBAAuB7C,GACvBwB,SAAS,CACRC,cAAeJ,EACfa,qBACAY,UAAWf,EAAKjH,KAChBiI,eAAgBhB,EAAKrC,KACrByC,0BACAf,UAAWI,EAASJ,UACpB4B,aAAc9L,IACdwK,cAAetC,gBAAcC,UAC7BsC,KAAM9K,OAAKyI,qBAEZsC,cAzDP,gCA2CevE,KA3Cf,kCA2DS,CACLF,eACA0E,QAAS,KA7Db,iDAjCF,oIAkGE,WACEoB,EACAzB,EACAM,GAHF,iGAKuBX,YAASW,EAAeV,WAL/C,cAKQC,EALR,OAK2D,GAL3D,SASYL,KAAKF,QAAQQ,QAChB4B,aACA1B,SAAS,CACRC,cAAeJ,EACf8B,UAAYnC,KAAKF,QAAQ5E,SAAsBrC,OAC5CU,UACH6I,SACE5B,EAAS4B,UACRpC,KAAKF,QAAQ5E,SAAsBrC,OAAOU,YAE9CqH,cAnBT,2CAqBa,GArBb,mBAQIzE,aARJ,KAqBI0E,QArBJ,uDAlGF,qIA2HE,WACE7B,EACAwB,GAFF,6IAGoB,GAHpB,SAKqC6B,YACjC,IAAIxM,OAAKC,UAAUkJ,EAAKsD,MACxB,IAAIzM,OAAKC,UAAUkJ,EAAKmD,YAP5B,0CAKSI,EALT,mBAUoCpC,YAASoC,GAV7C,0CAUSlC,EAVT,oBAcYL,KAAKF,QAAQQ,QAChBkC,YADG,2BACcxD,GADd,IACoBsD,KAAM,IAAIzM,OAAKC,UAAUkJ,EAAKsD,SACrD9B,SAAS,CACRC,cAAeJ,EACf8B,UAAYnC,KAAKF,QAAQ5E,SAAsBrC,OAC5CU,UACH6I,SACE5B,EAAS4B,UACRpC,KAAKF,QAAQ5E,SAAsBrC,OAAOU,UAC7CgJ,WAED3B,cAzBT,4CA2Ba,GA3Bb,mBAaIzE,aAbJ,KA2BI0E,QA3BJ,wDA3HF,mIAyJE,WACE7B,EACAwB,GAFF,mIAGoB,GAHpB,SAKuBL,YAASK,EAASJ,WALzC,cAKQC,EALR,OAKqD,GACnDtB,EAA0BC,GAN5B,SAUYgB,KAAKF,QAAQQ,QAChBmC,YAAYzD,GACZwB,SAAS,CACRC,cAAeJ,EACfD,UAAWI,EAASJ,UACpB+B,UAAYnC,KAAKF,QAAQ5E,SAAsBrC,OAC5CU,YAEJqH,cAlBT,2CAoBa,GApBb,mBASIzE,aATJ,KAoBI0E,QApBJ,wDAzJF,kIAiLE,WACE7B,EACAwB,EACAM,GAHF,2GAKuBX,YAASW,EAAeV,WAL/C,cAKQC,EALR,OAK2D,GAL3D,SAQUqB,YAAclB,EAASsB,UAAWtB,EAAS4B,UARrD,cAOQjB,EAPR,OASI,GATJ,SAWkDF,YAC9CH,EAAeV,UACfI,EAASsB,UACR9B,KAAKF,QAAQ5E,SAAsBrC,OAAOU,WAd/C,0CAWS2H,EAXT,UAiBQL,EAAU,GAjBlB,UAqBYb,KAAKF,QAAQQ,QAChBoC,WAAW1D,GACXwB,SAAS,CACRC,cAAeJ,EACfa,qBACAY,UAAWtB,EAASsB,UACpBX,0BACAiB,SAAWpC,KAAKF,QAAQ5E,SAAsBrC,OAC3CU,UACHyI,aAAc9L,MAEf0K,cAhCT,4CAkCIC,EAlCJ,mBAoBI1E,aApBJ,KAkCI0E,QAlCJ,wDAjLF,mIAuNE,WACE7B,EACAwB,EACAM,GAHF,6GAKuBX,YAASW,EAAeV,WAL/C,UAKQC,EALR,OAK2D,GAL3D,KAQIG,EAASmC,mBARb,qCAUYjB,YACJlB,EAASsB,UACR9B,KAAKF,QAAQ5E,SAAsBrC,OAAOU,WAZnD,mBAcM,GAdN,cAOQoJ,EAPR,KAeQC,EACJpC,EAASqC,wBAA0BhN,OAAKiN,QAAQC,WAhBpD,UAkBkD9B,YAC9CH,EAAeV,UACfI,EAASsB,UACR9B,KAAKF,QAAQ5E,SAAsBrC,OAAOU,WArB/C,uCAkBS2H,EAlBT,UAwBQL,EAAU,CAAC+B,GAxBnB,KA4BMI,QAAMC,yBACJ/M,IACAyM,EACAC,EAAkBrJ,UACjByG,KAAKF,QAAQ5E,SAAsBrC,OAAOU,UAC3C,GACAyF,EAAKkE,OAAOC,YAlCpB,KAoCYnD,KAAKF,QAAQQ,QAChB8C,UAAUpE,GArCnB,KAuCyBqB,EAvCzB,KAwCkCuC,EAAkBrJ,UAxCpD,KAyCU2H,EAzCV,KA0CqBV,EAASsB,UA1C9B,KA2CUa,EAEE7B,EAAeuC,YAAcxE,EAAUyE,IA7CnD,sBA8CgBlF,gBAAcC,UA9C9B,2BA+CgByC,EAAeuC,YAAcxE,EAAU0E,KA/CvD,kCAiDwBC,YAAWhD,EAASsB,UAAWhB,EAAe2C,OAjDtE,oBAkDkB,GAlDlB,yCAoDwBC,YAAalD,EAASsB,UAAWhB,EAAe2C,OApDxE,oBAqDkB,GArDlB,kDAsDkBzD,KAAKF,QAAQ5E,SAAsBrC,OAAOU,UAtD5D,MAuDyB6E,gBAAcC,UAvDvC,MAyDYmC,EAASmD,mBAAqBvF,gBAAcC,UAzDxD,MA0DwBnI,IA1DxB,MA2DgBL,OAAKyI,mBA3DrB,OAuCUmC,cAvCV,KAwCUoC,uBAxCV,KAyCU3B,mBAzCV,KA0CUY,UA1CV,KA2CUa,mBA3CV,KA4CUiB,sBA5CV,MAsDU3H,MAtDV,MAuDUyE,cAvDV,MAwDUiD,kBAxDV,MA0DU3B,aA1DV,MA2DUrB,KA3DV,sBAsCSH,SAtCT,iBA6DSK,QAAQA,GACRD,cA9DT,kCA+DMoC,QAAMa,wBACJ3N,IACAyM,EACC3C,KAAKF,QAAQ5E,SAAsBrC,OAAOU,UAC3C,IAnER,+BAsEIsH,EAtEJ,mBA2BI1E,aA3BJ,MAsEI0E,QAtEJ,yDAvNF,+IAiSE,kJACS,GACPL,EAFF,sDAGoB,GAHpB,SAKuBL,YAASK,EAASJ,WALzC,cAKQC,EALR,OAKqD,GALrD,SASYL,KAAKF,QAAQQ,QAChBwD,wBACAtD,SAAS,CACRC,cAAeJ,EACfD,UAAWI,EAASJ,UACpB+B,UAAYnC,KAAKF,QAAQ5E,SAAsBrC,OAC5CU,UACHwK,MAAOlO,OAAKmO,sBAEbpD,cAlBT,2CAoBa,GApBb,mBAQIzE,aARJ,KAoBI0E,QApBJ,wDAjSF,yIAyTE,WACE7B,GADF,yIAEc,GAFd,+BAGoB,GAHpB,SAKsCqD,YAClC,IAAIxM,OAAKC,UAAUkJ,EAAKsD,MACxBtD,EAAKmD,WAPT,0CAKSI,EALT,UAUQ0B,EAAiBjF,EAAKiF,eACxBjF,EAAKiF,eAAe/E,KAAI,SAACgF,GAAD,mBAAC,eACpBA,GADmB,IAEtBxF,KAAM,IAAI7I,OAAKC,UAAUoO,EAAExF,MAC3B0C,GAAI8C,EAAE9C,GAAK,IAAIvL,OAAKC,UAAUoO,EAAE9C,IAAM,KACtCtH,KAAM,IAAIjE,OAAKC,UAAUoO,EAAEpK,MAC3BoJ,OAAQ,IAAItD,KAAGsE,EAAEhB,aAEnB,KAlBN,UAsBYlD,KAAKF,QAAQQ,QAChB6D,qBADG,2BAECnF,GAFD,IAGFiF,iBACA3B,KAAM,IAAIzM,OAAKC,UAAUkJ,EAAKsD,SAE/B9B,SAAS,CACR+B,SACAtG,MAAQ+D,KAAKF,QAAQ5E,SAAsBrC,OAAOU,UAClDmH,cAAetC,gBAAcC,UAC7BsC,KAAM9K,OAAKyI,qBAEZsC,cAlCT,4CAoCa,GApCb,mBAqBIzE,aArBJ,KAoCI0E,QApCJ,wDAzTF,8DAkWauD,EAAb,WAKE,WAAYpF,GAAiD,yBAJ7DkB,QAI4D,OAH5DJ,aAG4D,OAF5Dc,iBAE4D,EAC1DZ,KAAKE,GAAKlB,EAAKkB,GACfF,KAAKF,QAAUd,EAAKc,QACpBE,KAAKY,YAAc,IAAIX,EAAmB,CACxCC,GAAIF,KAAKE,GACTJ,QAASE,KAAKF,UAVpB,+FAcE,WAAiByC,GAAjB,mGAC0BpC,YAASoC,GADnC,cACQ8B,EADR,OAC4C,GAD5C,SAGsBrE,KAAKF,QAAQwE,QAAQjE,MAAM7D,MAAM6H,GAHvD,cAGQhE,EAHR,yBAKS,IAAIR,EAAa,CACtBC,QAASE,KACTN,IAAK2E,EACL7F,KAAM6B,EAAM7B,KACZuB,OAAQM,KATZ,gDAdF,iIA2BE,WAAkBkC,GAAlB,mGAEIvC,KAAKF,QAAQ5E,SACbvC,WAAW0I,eAAekB,GAH9B,cACQgC,EADR,gBAMUvE,KAAKF,QAAQwE,QAAQlE,UAAUoE,MAAMhE,SAASiE,OAClD,YACAF,EAAW/F,MARjB,cAKQkG,EALR,yBAWS,IAAI7E,EAAa,CACtBC,QAASE,KACTN,IAAK6C,EACL/D,KAAM+F,EAAW/F,KACjBuB,OAAQ2E,KAfZ,gDA3BF,iIA8CE,WACE1F,GADF,uIAEc,GAFd,gCAK0CgB,KAAKY,YAAYL,YAAYvB,GALvE,uBAKU7C,EALV,EAKUA,aAAc0E,EALxB,EAKwBA,QALxB,SAOQ8D,YACH3E,KAAKF,QAAQ5E,SAAsBvC,WACnCqH,KAAKF,QAAQ5E,SAAsBrC,OACpCsD,EACA0E,GAXJ,gDA9CF,4IA6DE,WACE7B,EACAwB,EACAM,GAHF,qGAMUd,KAAKY,YAAYiB,uBACrB7C,EACAwB,EACAM,GATN,uBAKU3E,EALV,EAKUA,aAAc0E,EALxB,EAKwBA,QALxB,SAYQ8D,YACH3E,KAAKF,QAAQ5E,SAAsBvC,WACnCqH,KAAKF,QAAQ5E,SAAsBrC,OACpCsD,EACA0E,GAhBJ,gDA7DF,oIAiFE,WACE7B,EACAwB,EACAM,GAHF,qGAK0Cd,KAAKY,YAAYsB,WACvDlD,EACAwB,EACAM,GARJ,uBAKU3E,EALV,EAKUA,aAAc0E,EALxB,EAKwBA,QALxB,SAWQ8D,YACH3E,KAAKF,QAAQ5E,SAAsBvC,WACnCqH,KAAKF,QAAQ5E,SAAsBrC,OACpCsD,EACA0E,GAfJ,gDAjFF,qIAoGE,WACE7B,EACAwB,GAFF,uIAGoB,GAHpB,SAK0CR,KAAKY,YAAY4B,YACvDxD,EACAwB,GAPJ,uBAKUrE,EALV,EAKUA,aAAc0E,EALxB,EAKwBA,QALxB,SAUQ8D,YACH3E,KAAKF,QAAQ5E,SAAsBvC,WACnCqH,KAAKF,QAAQ5E,SAAsBrC,OACpCsD,EACA0E,GAdJ,gDApGF,iIAsHE,WACE7B,EACAwB,EACAM,GAHF,qGAK0Cd,KAAKY,YAAYwC,UACvDpE,EACAwB,EACAM,GARJ,uBAKU3E,EALV,EAKUA,aAAc0E,EALxB,EAKwBA,QALxB,kBAUS,CAAE1E,eAAc0E,YAVzB,gDAtHF,oIA4IE,WACE7B,EACAwB,EACAM,GAHF,qGAK0Cd,KAAKY,YAAY8B,WACvD1D,EACAwB,EACAM,GARJ,uBAKU3E,EALV,EAKUA,aAAc0E,EALxB,EAKwBA,QALxB,SAWQ8D,YACH3E,KAAKF,QAAQ5E,SAAsBvC,WACnCqH,KAAKF,QAAQ5E,SAAsBrC,OACpCsD,EACA0E,GAfJ,gDA5IF,qIA+JE,WACE7B,EACAwB,GAFF,uIAGoB,GAHpB,SAK0CR,KAAKY,YAAY6B,YACvDzD,EACAwB,GAPJ,uBAKUrE,EALV,EAKUA,aAAc0E,EALxB,EAKwBA,QALxB,SAUQ8D,YACH3E,KAAKF,QAAQ5E,SAAsBvC,WACnCqH,KAAKF,QAAQ5E,SAAsBrC,OACpCsD,EACA0E,GAdJ,gDA/JF,6IAiLE,yHACE7B,EADF,+BACS,GACPwB,EAFF,sDAGoB,GAHpB,SAMUR,KAAKY,YAAYkD,sBAAsB9E,EAAMwB,GANvD,uBAKUrE,EALV,EAKUA,aAAc0E,EALxB,EAKwBA,QALxB,UAQQ8D,YACH3E,KAAKF,QAAQ5E,SAAsBvC,WACnCqH,KAAKF,QAAQ5E,SAAsBrC,OACpCsD,EACA0E,GAZJ,iDAjLF,yIAiME,WACE7B,GADF,uIAEc,GAFd,+BAGoB,GAHpB,SAMUgB,KAAKY,YAAYuD,qBAAqBnF,GANhD,uBAKU7C,EALV,EAKUA,aAAc0E,EALxB,EAKwBA,QALxB,SAQQ8D,YACH3E,KAAKF,QAAQ5E,SAAsBvC,WACnCqH,KAAKF,QAAQ5E,SAAsBrC,OACpCsD,EACA0E,GAZJ,gDAjMF,+D,meClhBaa,EAAa,iDAAG,WAC3B5H,EACAjB,GAF2B,2FAIdhD,OAAKC,UAAU8O,mBAC1B,CAAC/L,EAAOgM,WAAY3O,IAAiB2O,WAAY/K,EAAK+K,YACtD1O,KANyB,mFAAH,wDAUbgK,EAAQ,iDAAG,WACtBoC,GADsB,2FAGT1M,OAAKC,UAAU8O,mBAC1B,CAACnG,EAAOC,KAAKoG,KAAiBvC,EAAOsC,YACrC5O,KALoB,mFAAH,sDASRgL,EAA0B,iDAAG,WACxCsB,EACAT,EACAiD,GAHwC,2FAK3BlP,OAAKC,UAAU8O,mBAC1B,CACEnG,EAAOC,KAAKoG,KACZvC,EAAOsC,WACP/C,EAAU+C,WACVE,EAAWF,YAEb5O,KAZsC,mFAAH,0DAgB1BoM,EAAS,iDAAG,WACvBC,EACArG,GAFuB,2FAIVpG,OAAKC,UAAU8O,mBAC1B,CAACnG,EAAOC,KAAKoG,KAAiB7I,EAAM4I,WAAYvC,EAAKuC,YACrD5O,KANqB,mFAAH,wDAmBTuN,EAAU,iDAAG,WACxB1J,EACA2J,GAFwB,kFAIxB7J,QAAQC,IAAI4J,GAJY,SAKX5N,OAAKC,UAAU8O,mBAC1B,CAACnG,EAAOC,KAAKsG,KAAclL,EAAK+K,WAAYpG,EAAOC,KAAK+E,IACxD1N,KAPsB,mFAAH,wDAWV2N,EAAY,iDAAG,WAC1B5J,EACA2J,GAF0B,2FAIb5N,OAAKC,UAAU8O,mBAC1B,CAACnG,EAAOC,KAAKuG,KAAgBnL,EAAK+K,WAAYpB,EAAMoB,SAAS,KAAM,IACnE7O,KANwB,mFAAH,0D,idCnDzBkP,EAAQ,KAER,IAAMC,EAAU1O,eAEV4C,EAAU5C,iCACVkC,EAAa,IAAIpC,OAAYuE,WACrBzB,GAGR+L,EAAQC,YAAY,CACtBC,QAAS,CACL5H,KAAM,QAEV6H,UAAW,CACPC,cAAe,CACXC,KAAM,CACFC,eAAgB,eAGxBC,UAAW,CACPF,KAAM,CACFG,mBAAe3M,EACf4M,QAAS,aAEbC,UAAW,CACPC,YAAa,GAEjBC,QAAS,CACLC,WAAY,OA8CbC,EAxCH,WAEV,IAAMC,EAAW7M,mBAAQ,kBAAMwF,wBAAcqG,KAAU,IAK/CiB,EAAU9M,mBACZ,iBAAM,CACF+M,cACAC,cACAC,cACAC,cACAC,YAAgB,CAAEtB,YAClBuB,YAAyB,CAAEvB,YAC3BwB,cACAC,cACAC,iBAEJ,IAGN,OACI,cAACC,EAAA,EAAD,CAAe1B,MAAOA,EAAtB,SACE,cAAC2B,EAAA,EAAD,CAAoBZ,SAAUA,EAA9B,SACE,cAACa,EAAA,EAAD,CAAgBZ,QAASA,EAASa,aAAa,EAA/C,SACE,cAAC,IAAD,UACE,cAACrP,EAAA,EAAD,CACEe,WAAYA,EACZuO,UAAWC,IACX9N,QAASA,EACT8L,QAASA,aChFViC,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,8BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,K,wGCqCYc,E,sCAhCCf,EAAkB,K,SAgCnBe,O,2BAAAA,I,uBAAAA,I,kCAAAA,M,KAyEL,IA6KMvD,EAAwB,iDAAG,WACpChM,EACAE,EACAsD,EACA0E,GAJoC,oHAKpCsH,EALoC,+BAKX,eACzBC,EANoC,gCAOpCC,EAPoC,uBAQpCC,EARoC,uBAUjCzP,EAAOU,UAV0B,sBAUT,IAAIgP,IAVK,UAYlCC,EAAc,IAAIC,cACtBtM,EAAamD,SAAQ,SAAAsB,GAAW,OAAI4H,EAAYE,IAAI9H,MAbd,KAelCyH,EAfkC,uCAelB1P,EAAWgQ,mBAAmBR,GAfZ,+BActCK,EAAYI,gBAd0B,KAgBpCC,UAEET,GACF,EAAAI,GAAYM,WAAZ,oBAA0BjI,EAAQ3B,KAAI,SAAA6J,GAAC,OAAIA,EAAExP,gBAE7C,EAAAiP,GAAYM,WAAZ,SAEIjQ,EAAOU,WAFX,mBAGOsH,EAAQ3B,KAAI,SAAA6J,GAAC,OAAIA,EAAExP,gBAIxBsH,EAAQvE,OAAS,IACnB,EAAAkM,GAAYQ,YAAZ,oBAA2BnI,IAExBuH,EA/BiC,kCAgChBvP,EAAOY,gBAAgB+O,GAhCP,QAgCpCA,EAhCoC,sBAmClCF,GACFA,IApCoC,UAuCTW,EAAsB,CACjDtQ,aACAuQ,kBAAmBV,IAzCiB,wBAuC9BW,EAvC8B,EAuC9BA,KAAMC,EAvCwB,EAuCxBA,KAvCwB,kBA4C/B,CAAED,OAAMC,SA5CuB,4CAAH,4DA+CxBC,EAAY,WACvB,OAAO,IAAIpR,MAAOC,UAAY,KAGzB,SAAe+Q,EAAtB,kC,sDAAO,8HACuCC,EADvC,EACuCA,kBACAvQ,EAFvC,EAEuCA,WAFvC,IAGuC2Q,eAHvC,MAGiDnC,EAHjD,EAYCoC,EAAiBL,EAAkBM,YAEnCC,EAAYJ,IACdD,EAAO,EAfN,SAgBoCzQ,EAAW+Q,mBAChDH,EACA,CACEI,eAAe,IAnBhB,cAgBCR,EAhBD,OAuBLvP,QAAQC,IAAI,oCAAqCsP,GAE7CS,GAAO,EACX,gCAAC,2FACSA,KAAQP,IAAcI,EAAYH,GAD3C,uBAEG3Q,EAAW+Q,mBAAmBH,EAAgB,CAC5CI,eAAe,IAHpB,SAKSE,EAAM,KALf,gEAAD,GA1BK,oBAmCwBC,EACvBX,EACAG,EACA3Q,EACA,UACA,GAxCD,WAmCGoR,EAnCH,8BA4CK,IAAIC,MAAM,kDA5Cf,YA8CCD,EAAaE,IA9Cd,uBA+CDrQ,QAAQsQ,MAAMH,EAAaE,KACrB,IAAID,MAAM,gDAhDf,QAmDHZ,GAAmB,OAAZW,QAAY,IAAZA,OAAA,EAAAA,EAAcX,OAAQ,EAnD1B,sDAqDHxP,QAAQsQ,MAAM,uBAAd,OACI,KAAIZ,QAtDL,uBAuDK,IAAIU,MAAM,kDAvDf,eAyDCG,EAAsD,KAzDvD,oBA4DSC,EAAoBzR,EAAYuQ,EAAmB,UA5D5D,QA2DDiB,EA3DC,OA6DChQ,MA7DD,+DA+DCgQ,IAAkBA,EAAeF,IA/DlC,qBAgEGE,EAAeE,KAhElB,iBAiEUjQ,EAAI+P,EAAeE,KAAK/N,OAAS,EAjE3C,aAiE8ClC,GAAK,GAjEnD,sBAkESkQ,EAAOH,EAAeE,KAAKjQ,IACxBmQ,WAAW,iBAnEvB,uBAoEW,IAAIP,MACN,uBAAyBM,EAAKE,MAAM,gBAAgBlO,SArE7D,UAiEwDlC,EAjExD,8BA0EK,IAAI4P,MAAMS,KAAKC,UAAUP,EAAeF,MA1E7C,yBA8EHL,GAAO,EA9EJ,4BAiFLhQ,QAAQC,IAAI,UAAWsP,EAAME,IAAcI,GAjFtC,kBAkFE,CAAEN,OAAMC,SAlFV,0E,+BAqFQgB,E,4FAAf,WACIzR,EACA6P,EACAL,GAHJ,yGAMsCxP,EAAWgS,iBAE3ChS,EAAWiS,0BARjB,cAMEpC,EAAYI,gBANd,OAWQiC,EAAWrC,EAAYsC,mBAEvBC,EAAkBvC,EAAYwC,WAAWH,GACzCI,EAAqBF,EAAgBrU,SAAS,UAE9CsI,EAAO,CAACiM,EADM,CAAEC,SAAU,SAAU/C,eAf5C,UAmBoBxP,EAAWwS,YAAY,sBAAuBnM,GAnBlE,aAmBQoM,EAnBR,QAoBUlB,MApBV,uBAqBU,IAAIF,MAAM,mCAAqCoB,EAAIlB,MAAMnR,SArBnE,iCAuBSqS,EAAIC,QAvBb,6C,+BA0BevB,E,4FAAf,WACIX,EACAG,EACA3Q,GAHJ,4GAIIwP,EAJJ,+BAI6B,SACzBmD,EALJ,gCAOM1B,GAAO,EACP2B,EAAwC,CAC1CnC,KAAM,EACNoC,cAAe,EACfvB,IAAK,MAEHwB,EAAQ,EAbd,SAciB,IAAIC,QAAJ,iDAAY,WAAOC,EAASC,GAAhB,2EACzBjS,YAAW,WACLiQ,IAGJA,GAAO,EACPhQ,QAAQC,IAAI,4BACZ+R,EAAO,CAAEtC,SAAS,OACjBA,GACH,IACEmC,EAAQ9S,EAAWkT,YACf1C,GACA,SAACkC,EAAQS,GACPlC,GAAO,EACP2B,EAAS,CACPtB,IAAKoB,EAAOpB,IACZb,KAAM0C,EAAQ1C,KACdoC,cAAe,GAEbH,EAAOpB,KACTrQ,QAAQC,IAAI,yBAA0BwR,EAAOpB,KAC7C2B,EAAOL,KAEP3R,QAAQC,IAAI,yBAA0BwR,GACtCM,EAAQJ,MAGZpD,GAEJ,MAAOpN,GACP6O,GAAO,EACPhQ,QAAQsQ,MAAM,oBAAqBf,EAAMpO,GA/BlB,UAiCjB6O,IAAQ0B,EAjCS,uBAmCvB,gCAAC,uHAEmC3S,EAAWoT,qBAAqB,CAC9D5C,IAHL,OAES6C,EAFT,OAKGT,EAASS,GAAqBA,EAAkB7R,MAAM,GACjDyP,IACE2B,EAEMA,EAAOtB,KAChBrQ,QAAQC,IAAI,iBAAkBsP,EAAMoC,GACpC3B,GAAO,EACPgC,EAAOL,EAAOtB,MACJsB,EAAOC,eAGjB5R,QAAQC,IAAI,wBAAyBsP,EAAMoC,GAC3C3B,GAAO,EACP+B,EAAQJ,IAJR3R,QAAQC,IAAI,4BAA6BsP,EAAMoC,GAN/C3R,QAAQC,IAAI,uBAAwBsP,EAAMoC,IARjD,gDAsBQ3B,GACHhQ,QAAQC,IAAI,8BAA+BsP,EAA3C,MAvBL,wDAAD,GAnCuB,SA8DjBU,EAAM,KA9DW,iEAAZ,yDAdjB,cAcE0B,EAdF,OAiFM5S,EAAWsT,wBAAwBR,IACrC9S,EAAWuT,wBAAwBT,GACrC7B,GAAO,EACPhQ,QAAQC,IAAI,mBAAoB0R,GApFlC,kBAqFSA,GArFT,4C,wBAuFO,SAAS1B,EAAMsC,GACpB,OAAO,IAAIT,SAAQ,SAAAC,GAAO,OAAIhS,WAAWgS,EAASQ,S","file":"static/js/main.f6d2b966.chunk.js","sourcesContent":["export const PREFIX: string = \"item\";\nexport const MARKER: string = \"marker\";\n","export const PREFIX = \"matches\";\n","import styled from 'styled-components';\nimport {useEffect, useState} from 'react';\nimport Button from '@material-ui/core/Button';\nimport {CircularProgress} from '@material-ui/core';\nimport {GatewayStatus, useGateway} from '@civic/solana-gateway-react';\nimport { BN } from '@project-serum/anchor'\n\nexport const CTAButton = styled(Button)`\n  display: block !important;\n  margin: 0 auto !important;\n  background-color: var(--title-text-color) !important;\n  min-width: 120px !important;\n  font-size: 1em !important;\n`;\n\nexport const MintButton = ({\n                               onMint\n                           }: {\n    onMint: () => Promise<void>;\n}) => {\n    return (\n        <CTAButton\n            disabled={false}\n            \n            onClick={async () => {\n                    console.log('Minting...');\n                    await onMint();\n            }}\n            variant=\"contained\"\n        >\n                        as tribute for your team; become winner @ some tokenz\n                    \n        </CTAButton>\n    );\n};\n","import { web3 } from \"@project-serum/anchor\";\n\nexport const NAMESPACE_ID = new web3.PublicKey(\n  \"nameAxQRRBnd4kLfsVoZBBXfrByZdZTkh8mULLxLyqV\"\n);\n\nexport const ITEM_ID = new web3.PublicKey(\n  \"itemX1XWs9dK8T2Zca4vEEPfCAhRc7yvYFntPjTTVx6\"\n);\n\nexport const PLAYER_ID = new web3.PublicKey(\n  \"p1exdMJcjVao65QdewkaZRUnU6VPSXhus9n2GzWfh98\"\n);\n\nexport const MATCHES_ID = new web3.PublicKey(\n  \"mtchsiT6WoLQ62fwCoiHMCfXJzogtfru4ovY8tXKrjJ\"\n);\n\nexport const WRAPPED_SOL_MINT = new web3.PublicKey(\n  \"So11111111111111111111111111111111111111112\"\n);\n\nexport const TOKEN_PROGRAM_ID = new web3.PublicKey(\n  \"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\"\n);\n\nexport const SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID = new web3.PublicKey(\n  \"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\"\n);\n\nexport const TOKEN_METADATA_PROGRAM_ID = new web3.PublicKey(\n  \"metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s\"\n);\n","import {useEffect, useMemo, useState} from \"react\";\nimport styled from \"styled-components\";\nimport confetti from \"canvas-confetti\";\nimport * as anchor from \"@project-serum/anchor\";\nimport { MatchesProgram } from \"./rain/contract/matches\";\nimport {getAtaForMint, toDate} from './utils';\nimport { Fanout, FanoutClient } from '@glasseaters/hydra-sdk'\nimport fetch from 'node-fetch';\nimport { getAssociatedAccountBalance } from \"@strata-foundation/spl-utils\";\n\nimport {\n    PublicKey,\n    Transaction,\n    LAMPORTS_PER_SOL,\n    Connection\n} from \"@solana/web3.js\";\nimport {WalletAdapterNetwork} from '@solana/wallet-adapter-base';\nimport {useConnection, useWallet} from \"@solana/wallet-adapter-react\";\nimport {WalletMultiButton} from \"@solana/wallet-adapter-react-ui\";\nimport Countdown from \"react-countdown\";\nimport {Snackbar, Paper, LinearProgress, Chip, Input, Button, Link} from \"@material-ui/core\";\nimport Alert from \"@material-ui/lab/Alert\";\nimport {AlertState} from './utils';\nimport {CTAButton, MintButton} from './MintButton';\n\nimport { TokenType } from \"raindrops-cli/build/state/matches\";\nimport { Token, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\n\nconst someDecs2 = {\"AD1bo7F21Cy8sfUkYXEBLJTTXA7Z8NREwMX1pZBgLakq\":9,\n\"2PAGcvionSsRsYv8vbbxbSfiNa8THnGT81q11vHU3faP\":9,\n\"EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v\":6,\n\"8HGyAAB1yoM1ttS7pXjHMa3dukTFGQggnFFH3hJZgzQh\":6,\n\"8upjSpvjcdpuzhfR1zriwg5NXkwDruejqNE9WNbPRtyA\":6,\n\"PRSMNsEPqhGVCH1TtWiJqPjJyh2cKrLostPZTNy1o5x\":6, \"openDKyuDPS6Ak1BuD3JtvkQGV3tzCxjpHUfe1mdC79\":9\n  }\nexport const getOracle = async (\n    seed: PublicKey,\n    payer: PublicKey\n  ): Promise<[PublicKey, number]> => {\n    return await PublicKey.findProgramAddress(\n      [Buffer.from(\"matches\"), payer.toBuffer(), seed.toBuffer()],\n      MATCHES_ID\n    );\n  };\n  \nexport const MATCHES_ID = new anchor.web3.PublicKey(\n    \"mtchsiT6WoLQ62fwCoiHMCfXJzogtfru4ovY8tXKrjJ\"\n  );\n  const fanout = new PublicKey(\"6Ko4TDy4ecqaP5VZrjLAVfoLHpN5Fzw46D2WAsUjD1jZ\")\n\nconst cluster = process.env.REACT_APP_SOLANA_NETWORK!.toString();\nconst decimals = process.env.REACT_APP_SPL_TOKEN_TO_MINT_DECIMALS ? +process.env.REACT_APP_SPL_TOKEN_TO_MINT_DECIMALS!.toString() : 9;\nconst splTokenName = process.env.REACT_APP_SPL_TOKEN_TO_MINT_NAME ? process.env.REACT_APP_SPL_TOKEN_TO_MINT_NAME.toString() : \"TOKEN\";\n\nconst WalletContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  flex-wrap: wrap;\n  justify-content: right;\n`;\n\nconst WalletAmount = styled.div`\n  color: black;\n  width: auto;\n  padding: 5px 5px 5px 16px;\n  min-width: 48px;\n  min-height: auto;\n  border-radius: 22px;\n  background-color: var(--main-text-color);\n  box-shadow: 0px 3px 5px -1px rgb(0 0 0 / 20%), 0px 6px 10px 0px rgb(0 0 0 / 14%), 0px 1px 18px 0px rgb(0 0 0 / 12%);\n  box-sizing: border-box;\n  transition: background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms, box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms, border 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;\n  font-weight: 500;\n  line-height: 1.75;\n  text-transform: uppercase;\n  border: 0;\n  margin: 0;\n  display: inline-flex;\n  outline: 0;\n  position: relative;\n  align-items: center;\n  user-select: none;\n  vertical-align: middle;\n  justify-content: flex-start;\n  gap: 10px;\n`;\n\nconst Wallet = styled.ul`\n  flex: 0 0 auto;\n  margin: 0;\n  padding: 0;\n`;\n\nconst ConnectButton = styled(WalletMultiButton)`\n  border-radius: 18px !important;\n  padding: 6px 16px;\n  background-color: #4E44CE;\n  margin: 0 auto;\n`;\n\nconst NFT = styled(Paper)`\n  min-width: 500px;\n  margin: 0 auto;\n  padding: 5px 20px 20px 20px;\n  flex: 1 1 auto;\n  background-color: var(--card-background-color) !important;\n  box-shadow: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22) !important;\n`;\n\nconst Card = styled(Paper)`\n  display: inline-block;\n  background-color: var(--countdown-background-color) !important;\n  margin: 5px;\n  min-width: 40px;\n  padding: 24px;\n\n  h1 {\n    margin: 0px;\n  }\n`;\n\nconst MintButtonContainer = styled.div`\n  button.MuiButton-contained:not(.MuiButton-containedPrimary).Mui-disabled {\n    color: #464646;\n  }\n\n  button.MuiButton-contained:not(.MuiButton-containedPrimary):hover,\n  button.MuiButton-contained:not(.MuiButton-containedPrimary):focus {\n    -webkit-animation: pulse 1s;\n    animation: pulse 1s;\n    box-shadow: 0 0 0 2em rgba(255, 255, 255, 0);\n  }\n\n  @-webkit-keyframes pulse {\n    0% {\n      box-shadow: 0 0 0 0 #ef8f6e;\n    }\n  }\n\n  @keyframes pulse {\n    0% {\n      box-shadow: 0 0 0 0 #ef8f6e;\n    }\n  }\n`;\n\nconst SolExplorerLink = styled.a`\n  color: var(--title-text-color);\n  border-bottom: 1px solid var(--title-text-color);\n  font-weight: bold;\n  list-style-image: none;\n  list-style-position: outside;\n  list-style-type: none;\n  outline: none;\n  text-decoration: none;\n  text-size-adjust: 100%;\n\n  :hover {\n    border-bottom: 2px solid var(--title-text-color);\n  }\n`;\n\nconst MainContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  margin-top: 20px;\n  margin-bottom: 20px;\n  margin-right: 4%;\n  margin-left: 4%;\n  text-align: center;\n  justify-content: center;\n`;\n\nconst MintContainer = styled.div`\n  display: flex;\n  flex-direction: row;\n  flex: 1 1 auto;\n  flex-wrap: wrap;\n  gap: 20px;\n`;\n\nconst DesContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  flex: 1 1 auto;\n  gap: 20px;\n`;\n\nconst Price = styled(Chip)`\n  position: absolute;\n  margin: 5px;\n  font-weight: bold;\n  font-size: 1.2em !important;\n  font-family: 'Patrick Hand', cursive !important;\n`;\n\nconst Image = styled.img`\n  height: 400px;\n  width: auto;\n  border-radius: 7px;\n  box-shadow: 5px 5px 40px 5px rgba(0, 0, 0, 0.5);\n`;\n\nconst BorderLinearProgress = styled(LinearProgress)`\n  margin: 20px;\n  height: 10px !important;\n  border-radius: 30px;\n  border: 2px solid white;\n  box-shadow: 5px 5px 40px 5px rgba(0, 0, 0, 0.5);\n  background-color: var(--main-text-color) !important;\n\n  > div.MuiLinearProgress-barColorPrimary {\n    background-color: var(--title-text-color) !important;\n  }\n\n  > div.MuiLinearProgress-bar1Determinate {\n    border-radius: 30px !important;\n    background-image: linear-gradient(270deg, rgba(255, 255, 255, 0.01), rgba(255, 255, 255, 0.5));\n  }\n`;\n\nexport interface HomeProps {\n    candyMachineId?: anchor.web3.PublicKey;\n    connection: anchor.web3.Connection;\n    txTimeout: number;\n    rpcHost: string;\n    network: WalletAdapterNetwork;\n}\nlet first = true;\nconst Home = (props: HomeProps) => {\n  const {sendTransaction} = useWallet()\n  const [endts, setEndts] = useState<number>(new Date().getTime() - 1);\n  const [balance, setBalance] = useState(0)\n  const [thepots, setthepots] = useState<string>()\n \n  const [index, setIndex] = useState<number>(0);\n    const [isMinting, setIsMinting] = useState(false); // true when user got to press MINT\n    const [isActive, setIsActive] = useState(false); // true when countdown completes or whitelisted\n    const [solanaExplorerLink, setSolanaExplorerLink] = useState<string>(\"\");\n    const [itemsAvailable, setItemsAvailable] = useState(0);\n    const [itemsRedeemed, setItemsRedeemed] = useState(0);\n    const [itemsRemaining, setItemsRemaining] = useState(0);\n    const [isSoldOut, setIsSoldOut] = useState(false);\n    const [payWithSplToken, setPayWithSplToken] = useState(false);\n    const [price, setPrice] = useState(1.38);\n    const [priceLabel, setPriceLabel] = useState<string>(\"SOL\");\n    const [whitelistPrice, setWhitelistPrice] = useState(0);\n    const [whitelistEnabled, setWhitelistEnabled] = useState(false);\n    const [isBurnToken, setIsBurnToken] = useState(false);\n    const [whitelistTokenBalance, setWhitelistTokenBalance] = useState(0);\n    const [isEnded, setIsEnded] = useState(false);\n    const [endDate, setEndDate] = useState<Date>();\n    const [isPresale, setIsPresale] = useState(false);\n    const [isWLOnly, setIsWLOnly] = useState(false);\n    const [toplay, setToplay] = useState(\"\");\n    \nconst { connection } = useConnection()\n\nconst wallet = useWallet();\n\n    const [alertState, setAlertState] = useState<AlertState>({\n        open: false,\n        message: \"\",\n        severity: undefined,\n    });\n\n    const [needTxnSplit, setNeedTxnSplit] = useState(true);\n    const rpcUrl = props.rpcHost;\n    const solFeesEstimation = 0.012; // approx of account creation fees\n\n    const anchorWallet = useMemo(() => {\n        if (\n            !wallet ||\n            !wallet.publicKey ||\n            !wallet.signAllTransactions ||\n            !wallet.signTransaction\n        ) {\n            return;\n        }\n\n        return {\n            publicKey: wallet.publicKey,\n            signAllTransactions: wallet.signAllTransactions,\n            signTransaction: wallet.signTransaction,\n        } as anchor.Wallet;\n    }, [wallet]);\n\n\n    const renderGoLiveDateCounter = ({days, hours, minutes, seconds}: any) => {\n        return (\n            <div><Card elevation={1}><h1>{days}</h1>Days</Card><Card elevation={1}><h1>{hours}</h1>\n                Hours</Card><Card elevation={1}><h1>{minutes}</h1>Mins</Card><Card elevation={1}>\n                <h1>{seconds}</h1>Secs</Card></div>\n        );\n    };\n\n    const renderEndDateCounter = ({days, hours, minutes}: any) => {\n        let label = \"\";\n        if (days > 0) {\n            label += days + \" days \"\n        }\n        if (hours > 0) {\n            label += hours + \" hours \"\n        }\n        label += (minutes + 1) + \" minutes left to blarg.\"\n        if (days + hours + minutes <= 0){\n          label = \"\"\n        }\n        return (\n            <div><h3>{label}</h3></div>\n        );\n    };\n\n    function throwConfetti(): void {\n        confetti({\n            particleCount: 400,\n            spread: 70,\n            origin: {y: 0.6},\n        });\n    }\n\n    const onMint = async (\n        beforeTransactions: Transaction[] = [],\n        afterTransactions: Transaction[] = [],\n    ) => {\n            if (wallet.connected && wallet.publicKey) {\n                setIsMinting(true);\n                // @ts-ignore\n                const provider = new anchor.Provider(connection, anchorWallet, {\n                    preflightCommitment: 'processed',\n                  });\n\n  const idl = {\"version\":\"0.1.0\",\"name\":\"matches\",\"instructions\":[{\"name\":\"createOrUpdateOracle\",\"accounts\":[{\"name\":\"oracle\",\"isMut\":true,\"isSigner\":false},{\"name\":\"payer\",\"isMut\":true,\"isSigner\":true},{\"name\":\"systemProgram\",\"isMut\":false,\"isSigner\":false},{\"name\":\"rent\",\"isMut\":false,\"isSigner\":false}],\"args\":[{\"name\":\"args\",\"type\":{\"defined\":\"CreateOrUpdateOracleArgs\"}}]},{\"name\":\"createMatch\",\"accounts\":[{\"name\":\"matchInstance\",\"isMut\":true,\"isSigner\":false},{\"name\":\"payer\",\"isMut\":true,\"isSigner\":true},{\"name\":\"systemProgram\",\"isMut\":false,\"isSigner\":false},{\"name\":\"rent\",\"isMut\":false,\"isSigner\":false}],\"args\":[{\"name\":\"args\",\"type\":{\"defined\":\"CreateMatchArgs\"}}]},{\"name\":\"updateMatch\",\"accounts\":[{\"name\":\"matchInstance\",\"isMut\":true,\"isSigner\":false},{\"name\":\"winOracle\",\"isMut\":false,\"isSigner\":false},{\"name\":\"authority\",\"isMut\":false,\"isSigner\":true}],\"args\":[{\"name\":\"args\",\"type\":{\"defined\":\"UpdateMatchArgs\"}}]},{\"name\":\"updateMatchFromOracle\",\"accounts\":[{\"name\":\"matchInstance\",\"isMut\":true,\"isSigner\":false},{\"name\":\"winOracle\",\"isMut\":false,\"isSigner\":false},{\"name\":\"clock\",\"isMut\":false,\"isSigner\":false}],\"args\":[]},{\"name\":\"drainOracle\",\"accounts\":[{\"name\":\"matchInstance\",\"isMut\":false,\"isSigner\":false},{\"name\":\"oracle\",\"isMut\":true,\"isSigner\":false},{\"name\":\"authority\",\"isMut\":false,\"isSigner\":true},{\"name\":\"receiver\",\"isMut\":true,\"isSigner\":false}],\"args\":[{\"name\":\"args\",\"type\":{\"defined\":\"DrainOracleArgs\"}}]},{\"name\":\"drainMatch\",\"accounts\":[{\"name\":\"matchInstance\",\"isMut\":true,\"isSigner\":false},{\"name\":\"authority\",\"isMut\":false,\"isSigner\":true},{\"name\":\"receiver\",\"isMut\":false,\"isSigner\":false}],\"args\":[]},{\"name\":\"leaveMatch\",\"accounts\":[{\"name\":\"matchInstance\",\"isMut\":true,\"isSigner\":false},{\"name\":\"receiver\",\"isMut\":false,\"isSigner\":false},{\"name\":\"tokenAccountEscrow\",\"isMut\":true,\"isSigner\":false},{\"name\":\"tokenMint\",\"isMut\":true,\"isSigner\":false},{\"name\":\"destinationTokenAccount\",\"isMut\":true,\"isSigner\":false},{\"name\":\"tokenProgram\",\"isMut\":false,\"isSigner\":false}],\"args\":[{\"name\":\"args\",\"type\":{\"defined\":\"LeaveMatchArgs\"}}]},{\"name\":\"disburseTokensByOracle\",\"accounts\":[{\"name\":\"matchInstance\",\"isMut\":true,\"isSigner\":false},{\"name\":\"tokenAccountEscrow\",\"isMut\":true,\"isSigner\":false},{\"name\":\"tokenMint\",\"isMut\":true,\"isSigner\":false},{\"name\":\"destinationTokenAccount\",\"isMut\":true,\"isSigner\":false},{\"name\":\"winOracle\",\"isMut\":false,\"isSigner\":false},{\"name\":\"originalSender\",\"isMut\":true,\"isSigner\":false},{\"name\":\"systemProgram\",\"isMut\":false,\"isSigner\":false},{\"name\":\"tokenProgram\",\"isMut\":false,\"isSigner\":false},{\"name\":\"rent\",\"isMut\":false,\"isSigner\":false}],\"args\":[{\"name\":\"args\",\"type\":{\"defined\":\"DisburseTokensByOracleArgs\"}}]},{\"name\":\"joinMatch\",\"accounts\":[{\"name\":\"matchInstance\",\"isMut\":true,\"isSigner\":false},{\"name\":\"tokenTransferAuthority\",\"isMut\":false,\"isSigner\":true},{\"name\":\"tokenAccountEscrow\",\"isMut\":true,\"isSigner\":false},{\"name\":\"tokenMint\",\"isMut\":true,\"isSigner\":false},{\"name\":\"sourceTokenAccount\",\"isMut\":true,\"isSigner\":false},{\"name\":\"sourceItemOrPlayerPda\",\"isMut\":false,\"isSigner\":false},{\"name\":\"payer\",\"isMut\":true,\"isSigner\":true},{\"name\":\"systemProgram\",\"isMut\":false,\"isSigner\":false},{\"name\":\"validationProgram\",\"isMut\":false,\"isSigner\":false},{\"name\":\"tokenProgram\",\"isMut\":false,\"isSigner\":false},{\"name\":\"rent\",\"isMut\":false,\"isSigner\":false}],\"args\":[{\"name\":\"args\",\"type\":{\"defined\":\"JoinMatchArgs\"}}]}],\"accounts\":[{\"name\":\"Match\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"namespaces\",\"type\":{\"option\":{\"vec\":{\"defined\":\"NamespaceAndIndex\"}}}},{\"name\":\"winOracle\",\"type\":\"publicKey\"},{\"name\":\"winOracleCooldown\",\"type\":\"u64\"},{\"name\":\"lastOracleCheck\",\"type\":\"u64\"},{\"name\":\"authority\",\"type\":\"publicKey\"},{\"name\":\"state\",\"type\":{\"defined\":\"MatchState\"}},{\"name\":\"leaveAllowed\",\"type\":\"bool\"},{\"name\":\"minimumAllowedEntryTime\",\"type\":{\"option\":\"u64\"}},{\"name\":\"bump\",\"type\":\"u8\"},{\"name\":\"currentTokenTransferIndex\",\"type\":\"u64\"},{\"name\":\"tokenTypesAdded\",\"type\":\"u64\"},{\"name\":\"tokenTypesRemoved\",\"type\":\"u64\"},{\"name\":\"tokenEntryValidation\",\"type\":{\"option\":{\"vec\":{\"defined\":\"TokenValidation\"}}}},{\"name\":\"tokenEntryValidationRoot\",\"type\":{\"option\":{\"defined\":\"Root\"}}},{\"name\":\"joinAllowedDuringStart\",\"type\":\"bool\"}]}},{\"name\":\"PlayerWinCallbackBitmap\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"matchKey\",\"type\":\"publicKey\"}]}},{\"name\":\"WinOracle\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"finalized\",\"type\":\"bool\"},{\"name\":\"tokenTransferRoot\",\"type\":{\"option\":{\"defined\":\"Root\"}}},{\"name\":\"tokenTransfers\",\"type\":{\"option\":{\"vec\":{\"defined\":\"TokenDelta\"}}}}]}}],\"types\":[{\"name\":\"CreateOrUpdateOracleArgs\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"tokenTransferRoot\",\"type\":{\"option\":{\"defined\":\"Root\"}}},{\"name\":\"tokenTransfers\",\"type\":{\"option\":{\"vec\":{\"defined\":\"TokenDelta\"}}}},{\"name\":\"seed\",\"type\":\"publicKey\"},{\"name\":\"space\",\"type\":\"u64\"},{\"name\":\"finalized\",\"type\":\"bool\"}]}},{\"name\":\"DrainOracleArgs\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"seed\",\"type\":\"publicKey\"}]}},{\"name\":\"CreateMatchArgs\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"matchState\",\"type\":{\"defined\":\"MatchState\"}},{\"name\":\"tokenEntryValidationRoot\",\"type\":{\"option\":{\"defined\":\"Root\"}}},{\"name\":\"tokenEntryValidation\",\"type\":{\"option\":{\"vec\":{\"defined\":\"TokenValidation\"}}}},{\"name\":\"winOracle\",\"type\":\"publicKey\"},{\"name\":\"winOracleCooldown\",\"type\":\"u64\"},{\"name\":\"authority\",\"type\":\"publicKey\"},{\"name\":\"space\",\"type\":\"u64\"},{\"name\":\"leaveAllowed\",\"type\":\"bool\"},{\"name\":\"joinAllowedDuringStart\",\"type\":\"bool\"},{\"name\":\"minimumAllowedEntryTime\",\"type\":{\"option\":\"u64\"}}]}},{\"name\":\"UpdateMatchArgs\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"matchState\",\"type\":{\"defined\":\"MatchState\"}},{\"name\":\"tokenEntryValidationRoot\",\"type\":{\"option\":{\"defined\":\"Root\"}}},{\"name\":\"tokenEntryValidation\",\"type\":{\"option\":{\"vec\":{\"defined\":\"TokenValidation\"}}}},{\"name\":\"winOracleCooldown\",\"type\":\"u64\"},{\"name\":\"authority\",\"type\":\"publicKey\"},{\"name\":\"leaveAllowed\",\"type\":\"bool\"},{\"name\":\"joinAllowedDuringStart\",\"type\":\"bool\"},{\"name\":\"minimumAllowedEntryTime\",\"type\":{\"option\":\"u64\"}}]}},{\"name\":\"JoinMatchArgs\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"amount\",\"type\":\"u64\"},{\"name\":\"tokenEntryValidationProof\",\"type\":{\"option\":{\"vec\":{\"array\":[\"u8\",32]}}}},{\"name\":\"tokenEntryValidation\",\"type\":{\"option\":{\"defined\":\"TokenValidation\"}}}]}},{\"name\":\"LeaveMatchArgs\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"amount\",\"type\":\"u64\"}]}},{\"name\":\"DisburseTokensByOracleArgs\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"tokenDeltaProofInfo\",\"type\":{\"option\":{\"defined\":\"TokenDeltaProofInfo\"}}}]}},{\"name\":\"TokenDeltaProofInfo\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"tokenDeltaProof\",\"type\":{\"vec\":{\"array\":[\"u8\",32]}}},{\"name\":\"tokenDelta\",\"type\":{\"defined\":\"TokenDelta\"}},{\"name\":\"totalProof\",\"type\":{\"vec\":{\"array\":[\"u8\",32]}}},{\"name\":\"total\",\"type\":\"u64\"}]}},{\"name\":\"Root\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"root\",\"type\":{\"array\":[\"u8\",32]}}]}},{\"name\":\"Callback\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"key\",\"type\":\"publicKey\"},{\"name\":\"code\",\"type\":\"u64\"}]}},{\"name\":\"ValidationArgs\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"instruction\",\"type\":{\"array\":[\"u8\",8]}},{\"name\":\"extraIdentifier\",\"type\":\"u64\"},{\"name\":\"tokenValidation\",\"type\":{\"defined\":\"TokenValidation\"}}]}},{\"name\":\"NamespaceAndIndex\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"namespace\",\"type\":\"publicKey\"},{\"name\":\"indexed\",\"type\":\"bool\"},{\"name\":\"inherited\",\"type\":{\"defined\":\"InheritanceState\"}}]}},{\"name\":\"TokenDelta\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"from\",\"type\":\"publicKey\"},{\"name\":\"to\",\"type\":{\"option\":\"publicKey\"}},{\"name\":\"tokenTransferType\",\"type\":{\"defined\":\"TokenTransferType\"}},{\"name\":\"mint\",\"type\":\"publicKey\"},{\"name\":\"amount\",\"type\":\"u64\"}]}},{\"name\":\"TokenValidation\",\"type\":{\"kind\":\"struct\",\"fields\":[{\"name\":\"filter\",\"type\":{\"defined\":\"Filter\"}},{\"name\":\"isBlacklist\",\"type\":\"bool\"},{\"name\":\"validation\",\"type\":{\"option\":{\"defined\":\"Callback\"}}}]}},{\"name\":\"MatchState\",\"type\":{\"kind\":\"enum\",\"variants\":[{\"name\":\"Draft\"},{\"name\":\"Initialized\"},{\"name\":\"Started\"},{\"name\":\"Finalized\"},{\"name\":\"PaidOut\"},{\"name\":\"Deactivated\"}]}},{\"name\":\"PermissivenessType\",\"type\":{\"kind\":\"enum\",\"variants\":[{\"name\":\"TokenHolder\"},{\"name\":\"ParentTokenHolder\"},{\"name\":\"UpdateAuthority\"},{\"name\":\"Anybody\"}]}},{\"name\":\"InheritanceState\",\"type\":{\"kind\":\"enum\",\"variants\":[{\"name\":\"NotInherited\"},{\"name\":\"Inherited\"},{\"name\":\"Overridden\"}]}},{\"name\":\"TokenType\",\"type\":{\"kind\":\"enum\",\"variants\":[{\"name\":\"Player\"},{\"name\":\"Item\"},{\"name\":\"Any\"}]}},{\"name\":\"TokenTransferType\",\"type\":{\"kind\":\"enum\",\"variants\":[{\"name\":\"PlayerToPlayer\"},{\"name\":\"PlayerToEntrant\"},{\"name\":\"Normal\"}]}},{\"name\":\"Filter\",\"type\":{\"kind\":\"enum\",\"variants\":[{\"name\":\"None\"},{\"name\":\"All\"},{\"name\":\"Namespace\",\"fields\":[{\"name\":\"namespace\",\"type\":\"publicKey\"}]},{\"name\":\"Parent\",\"fields\":[{\"name\":\"key\",\"type\":\"publicKey\"}]},{\"name\":\"Mint\",\"fields\":[{\"name\":\"mint\",\"type\":\"publicKey\"}]}]}},{\"name\":\"ErrorCode\",\"type\":{\"kind\":\"enum\",\"variants\":[{\"name\":\"IncorrectOwner\"},{\"name\":\"Uninitialized\"},{\"name\":\"MintMismatch\"},{\"name\":\"TokenTransferFailed\"},{\"name\":\"NumericalOverflowError\"},{\"name\":\"TokenMintToFailed\"},{\"name\":\"TokenBurnFailed\"},{\"name\":\"DerivedKeyInvalid\"},{\"name\":\"InvalidStartingMatchState\"},{\"name\":\"InvalidUpdateMatchState\"},{\"name\":\"InvalidOracleUpdate\"},{\"name\":\"CannotDrainYet\"},{\"name\":\"CannotLeaveMatch\"},{\"name\":\"ReceiverMustBeSigner\"},{\"name\":\"PublicKeyMismatch\"},{\"name\":\"AtaShouldNotHaveDelegate\"},{\"name\":\"CannotEnterMatch\"},{\"name\":\"InvalidProof\"},{\"name\":\"RootNotPresent\"},{\"name\":\"MustPassUpObject\"},{\"name\":\"NoValidValidationFound\"},{\"name\":\"Blacklisted\"},{\"name\":\"NoTokensAllowed\"},{\"name\":\"InvalidValidation\"},{\"name\":\"NoDeltasFound\"},{\"name\":\"UsePlayerEndpoint\"},{\"name\":\"FromDoesNotMatch\"},{\"name\":\"CannotDeltaMoreThanAmountPresent\"},{\"name\":\"DeltaMintDoesNotMatch\"},{\"name\":\"DestinationMismatch\"},{\"name\":\"MatchMustBeInFinalized\"},{\"name\":\"AtaDelegateMismatch\"},{\"name\":\"OracleAlreadyFinalized\"},{\"name\":\"OracleCooldownNotPassed\"},{\"name\":\"MatchMustBeDrained\"},{\"name\":\"NoParentPresent\"},{\"name\":\"ReinitializationDetected\"}]}}]}// await anchor.Program.fetchIdl(MATCHES_ID, provider);\n\n  const program = new anchor.Program(idl as anchor.Idl, MATCHES_ID, provider);\n\n \n                const anchorProgram =  new MatchesProgram({\n                    id: MATCHES_ID,\n                    // @ts-ignore\n                    program,\n                  });\n                  console.log(anchorProgram)\n                let blarg = new PublicKey(\"BCUfkAyJYpxBpjT7AhnHSbW2PnUMMhoKfDSdmd5fga1m\")\n                const config = (await (await fetch('https://www.autist.design/blargs')).json()) \n            \n                console.log(index)\n                // @ts-ignore\n                  const setup = config.tokensToJoin[index];\n                  console.log(setup)\n\n                      // Generate a new wallet keypair and airdrop SOL\n                      const fromWallet = anchorWallet?.publicKey// Keypair.generate();\n                     \n                      // Generate a new wallet to receive newly minted token\n                      const toWallet = fanout//Keypair.generate();\n                  \n                      // Create new token mint\n                      const mint = new PublicKey(setup.mint)//await createMint(connection, fromWallet, fromWallet.publicKey, null, 9);\n                  \n                      // Get the token account of the fromWallet address, and if it does not exist, create it\n                      // @ts-ignore\n                      let tokAccs = await connection.getTokenAccountsByOwner(anchorWallet.publicKey as PublicKey,{mint:new PublicKey(setup.mint)})\n                      let bal = 0\n                      let winning = 0 \n                      let winner: PublicKey\n                for (var i in tokAccs.value){\n                  try {\n                    let eh1 = await connection.getTokenAccountBalance(tokAccs.value[i].pubkey)\n                   if (eh1.value.uiAmount || 0 > winning ){\n                      winning = eh1.value.uiAmount || 0\n                      winner = tokAccs.value[i].pubkey\n                    }\n\n                  } catch (err){\n                    console.log('wat')\n                  }\n                }\n                // @ts-ignore\n                      const fromTokenAccount = winner \n                       tokAccs = await connection.getTokenAccountsByOwner(toWallet as PublicKey,{mint:new PublicKey(setup.mint)})\n                       winning = 0 \n                for (var i in tokAccs.value){\n                  try {\n                    let eh1 = await connection.getTokenAccountBalance(tokAccs.value[i].pubkey)\n                   if (eh1.value.uiAmount || 0 > winning ){\n                      winning = eh1.value.uiAmount || 0\n                      winner = tokAccs.value[i].pubkey\n                    }\n\n                  } catch (err){\n                    console.log('wat')\n                  }\n                }\n                // @ts-ignore\n                      const toTokenAccount = winner \n                  \n                     \n                      // Transfer the new token to the \"toTokenAccount\" we just created\n                      const transaction = new anchor.web3.Transaction().add(\n                        Token.createTransferInstruction(\n                            TOKEN_PROGRAM_ID,\n                            fromTokenAccount,\n                            toTokenAccount,\n                            // @ts-ignore\n                            anchorWallet.publicKey,\n                            [],\n                            Math.ceil(setup.amount / 100 * 10)\n                        )\n                      )\n                      \n                  let stupidjare = await anchorProgram.joinMatch (\n                    {\n                        // @ts-ignore\n                      amount: new anchor.BN(setup.amount),\n                      // @ts-ignore\n                      escrowBump: null,\n                      tokenEntryValidation: null,\n                      tokenEntryValidationProof: null,\n                    },\n                    {\n                        // @ts-ignore\n                      tokenMint: new PublicKey(setup.mint),\n                      sourceTokenAccount: null,\n                      tokenTransferAuthority: null,\n                      // @ts-ignore\n                      validationProgram: setup.validationProgram\n                      // @ts-ignore\n                        ? new PublicKey(setup.validationProgram)\n                        : null,\n                    },\n                    {\n                      winOracle: config.winOracle\n                        ? new PublicKey(config.winOracle)\n                        : (\n                            await getOracle(\n                              new PublicKey(config.oracleState.seed),\n            \n                              config.oracleState.authority\n                                ? new PublicKey(config.oracleState.authority)\n                                : wallet.publicKey\n                            )\n                          )[0],\n                          // @ts-ignore\n                      sourceType: setup.sourceType as TokenType,\n                      index:new anchor.BN(index),\n                    }\n                  );\n                  transaction.add(...stupidjare.instructions)\n                  transaction.recentBlockhash = await (await connection.getLatestBlockhash()).blockhash\n                  transaction.feePayer = anchorWallet?.publicKey\n                  transaction.partialSign(...stupidjare.signers)\n                      const signature = await sendTransaction(transaction, connection)\n                      \n                      const response = await connection.confirmTransaction(signature, 'processed')\n                      console.log('response', response)\n                      \n                  const jconfig = (await (await fetch('https://www.autist.design/join?me=' + wallet.publicKey.toBase58() + '&tok=' + setup.mint + '&amount=' + setup.amount.toString())).json()) \n                  \n    const winOracle = jconfig.winOracle\n    ? new PublicKey(jconfig.winOracle)\n    : (\n        await getOracle(\n          new PublicKey(jconfig.oracleState.seed),\n\n          jconfig.oracleState.authority\n            ? new PublicKey(jconfig.oracleState.authority)\n            : wallet.publicKey\n        )\n      )[0];\n  const oracleInstance = await anchorProgram.fetchOracle(winOracle);\n  console.log(jconfig)\n  for (let i = 0; i < oracleInstance.object.tokenTransfers.length; i++) {\n    const tfer = oracleInstance.object.tokenTransfers[i];\n  /*\n    setTimeout(async function(){\n    await anchorProgram.disburseTokensByOracle(\n      {\n        // @ts-ignore\n        escrowBump: null,\n        tokenDeltaProofInfo: null,\n      },\n      {\n        winOracle,\n      },\n      {\n        tokenDelta: tfer,\n      }\n    );\n    }, 13800) */\n  }\n             \n            }     \n//            const hehe = (await (await fetch('https://www.autist.design/leavejoinlol')).json()) \n                   \n    };\n    useEffect(() => {\n        (async () => {\n            if (anchorWallet) {\n   \n   setTimeout(async function(){\n       if (first){\n     first = false;\n    \n    try {\n        console.log(anchorWallet.publicKey as PublicKey,{mint:mintPublicKey})\n      const tokAccs = await connection.getTokenAccountsByOwner(anchorWallet.publicKey as PublicKey,{mint:mintPublicKey})\n      let bal = 0\nfor (var i in tokAccs.value){\n  try {\n    let eh1 = await connection.getTokenAccountBalance(tokAccs.value[i].pubkey)\n    let eh2 = eh1.value.uiAmount || 0\nbal+= eh2\n  }\n  catch(err){\nconsole.log(err)\n  }\n  setBalance(bal)\n}\n      // @ts-ignore\n  //var tokenAmount = await getAssociatedAccountBalance(connection2, wallet.publicKey, mintPublicKey)\n  // @ts-ignore\n  //setBalance( tokenAmount.uiAmount)\n  }\n  catch (err){\n  console.log(err)\n  }\n\n  \n   setInterval(async function(){\n     \n\n     try {\n         console.log(anchorWallet.publicKey as PublicKey,{mint:mintPublicKey})\n       const tokAccs = await connection.getTokenAccountsByOwner(anchorWallet.publicKey as PublicKey,{mint:mintPublicKey})\n       let bal = 0\n for (var i in tokAccs.value){\n   try {\n     let eh1 = await connection.getTokenAccountBalance(tokAccs.value[i].pubkey)\n     let eh2 = eh1.value.uiAmount || 0\n bal+= eh2\n   }\n   catch(err){\n console.log(err)\n   }\n   setBalance(bal)\n }\n       // @ts-ignore\n   //var tokenAmount = await getAssociatedAccountBalance(connection2, wallet.publicKey, mintPublicKey)\n   // @ts-ignore\n   //setBalance( tokenAmount.uiAmount)\n   }\n   catch (err){\n   console.log(err)\n   }\n \n   \n }, 12500)     \n   }\n }, 500)\n            }\n        })();\n    }, [anchorWallet, props.connection]);\n\nfunction changeIndex(e: any){\n    try {\n    setIndex(parseInt(e.target.value))\n    }\n    catch (err){\n\n    }\n}\nconst mintPublicKey = new PublicKey(\"2PAGcvionSsRsYv8vbbxbSfiNa8THnGT81q11vHU3faP\")\nvar [shares, setShares] = useState(\"1.38\");\n\nvar connection2 = new Connection('https://ssc-dao.genesysgo.net/', \"confirmed\");\n\nasync function onChange(e: any){\n    e.preventDefault()\n    console.log(e.target.value)\n    setShares(e.target.value)\n    }\n\nasync function claim(){\n  if (wallet){    var fanoutSdk: FanoutClient;\n  // @ts-ignore\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: 'processed',\n  });\n  fanoutSdk = new FanoutClient(\n    connection2,\n    provider.wallet\n);\n  let ixes = [[]]\n  let acount = 0\n  let acount2 = 0\n\nfor (var der of Object.keys(someDecs2)){\n  acount++\nvar ix = await fanoutSdk.distributeTokenMemberInstructions(\n  {\n    \n    distributeForMint: true,\n    // @ts-ignore\n    fanout: fanout,\n    fanoutMint: new PublicKey(der),\n    // @ts-ignore\n    membershipMint: mintPublicKey,\n   // @ts-ignore\n    member: wallet.publicKey,\n    // @ts-ignore\n    payer: wallet.publicKey\n\n  }\n);\nfor (var bla of ix.instructions){\n  // @ts-ignore\n  ixes[acount2].push(bla)\n}\nif (acount > 1){\n  acount = 0\n  acount2++\n  ixes.push([])\n\n\n}\n}\nconsole.log(ixes.length)\nfor (var i = 0; i <= acount2; i++){\n  if (i in ixes){\n  if (ixes[i].length > 0){\nvar  tx2 = await fanoutSdk.sendInstructions(\n  [...ixes[i]],\n  // [...ix.instructions, ...ix3.instructions],\n  [],\n  // @ts-ignore\n  wallet.publicKey\n  );\n  }\n}\n}\n}\n}\nasync function doit(){\n\nif (wallet){\n\n  var fanoutSdk: FanoutClient;\n  // @ts-ignore\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: 'processed',\n  });\n  fanoutSdk = new FanoutClient(\n    connection2,\n    provider.wallet\n);\nlet blarg = await fanoutSdk.fetch<Fanout>(fanout, Fanout)\nconsole.log(blarg.membershipMint?.toBase58())\nconsole.log(blarg.membershipMint?.toBase58())\nconsole.log(blarg.membershipMint?.toBase58())\nconsole.log(blarg.membershipMint?.toBase58())\nconsole.log(blarg.membershipMint?.toBase58())\nconsole.log(blarg.membershipMint?.toBase58())\nconsole.log(blarg.membershipMint?.toBase58())\nconsole.log(blarg.membershipMint?.toBase58())\nconsole.log( (parseFloat(shares) * 10 ** 9))\nvar  ixs = await fanoutSdk.stakeTokenMemberInstructions(\n      {\n          \n          shares:  (parseFloat(shares) * 10 ** 9),\n          // @ts-ignore\n          fanout: fanout,\n          membershipMint: mintPublicKey,\n         // @ts-ignore\n          member: wallet.publicKey,\n          // @ts-ignore\n          payer: wallet.publicKey\n      }\n  );var tx = await fanoutSdk.sendInstructions(\n    ixs.instructions,\n    [],\n    // @ts-ignore\n    wallet.publicKey\n);\n\n}\n}\n\n/*\nconsole.log(321)\nconst { info: tokenBonding2 } = useTokenBondingFromMint(mintPublicKey);\nconst { price: price2, loading: l2 } = useLivePrice(tokenBonding2?.publicKey);\nif (price2){\n  if (!l2 && !isNaN(price2)){\n // console.log(price2)\n  }\n}\n*/\nasync function us(){\n\n  if (wallet){\n    var fanoutSdk: FanoutClient;\n  // @ts-ignore\n  const provider = new anchor.Provider(connection, anchorWallet, {\n    preflightCommitment: 'processed',\n  });\n  fanoutSdk = new FanoutClient(\n    connection2,\n    provider.wallet\n);\n  \n  await fanoutSdk.unstakeTokenMember({\n      // @ts-ignore\n    fanout: fanout,\n    // @ts-ignore\n    member: wallet.publicKey,\n    // @ts-ignore\n    payer: wallet.publicKey\n}\n);\n  }\n\n}\n    return (\n        <main>\n            <MainContainer>\n                <WalletContainer>\n                    <Wallet>\n                        {wallet ?\n                            <ConnectButton/> :\n                            <ConnectButton>Connect Wallet</ConnectButton>}\n                    </Wallet>\n                </WalletContainer>\n                <br/>\n                <MintContainer>\n                    <DesContainer>\n                        <NFT elevation={3}>\n                          \n                            <div><Price\n                                label={isActive && whitelistEnabled && (whitelistTokenBalance > 0) ? (whitelistPrice + \" \" + priceLabel) : (price + \" \" + priceLabel)}/><Image\n                                src=\"cool-cats.gif\"\n                                alt=\"NFT To Mint\"/></div>\n                            <br/>\n                            \n                                <div>\n<br />\nyou hodl {balance} social tok, grab moar here: <Link href={\"https://app.strataprotocol.com/swap/2PAGcvionSsRsYv8vbbxbSfiNa8THnGT81q11vHU3faP\"} >nfa</Link>\n<br />\nmm pinatadrastick... <br /> <br /> \n\n        <CTAButton onClick={claim} >Distribute to self..</CTAButton>\n<br />\n<Input  style={{color:\"black\", fontSize: \"30px;\", backgroundColor: \"grey\"}} type=\"text\" onInput={onChange} value={shares} />\n<br /><br />\n\n\n<CTAButton  onClick={doit} >Stake</CTAButton>\n<br />\n\n<CTAButton  onClick={us} >Unstake All</CTAButton>\n<br />\n                </div>\n                        </NFT>\n                    </DesContainer>\n                </MintContainer>\n                \n            </MainContainer>\n            <Snackbar\n                open={alertState.open}\n                autoHideDuration={6000}\n                onClose={() => setAlertState({...alertState, open: false})}\n            >\n                <Alert\n                    onClose={() => setAlertState({...alertState, open: false})}\n                    severity={alertState.severity}\n                >\n                    {alertState.message}\n                </Alert>\n            </Snackbar>\n        </main>\n    );\n};\n\nexport default Home;\n","export const PREFIX: string = \"namespace\";\n","export const PREFIX: string = \"player\";\n","import { web3 } from \"@project-serum/anchor\";\nimport { TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID } from \"../constants/programIds\";\n\nexport function createAssociatedTokenAccountInstruction(\n  associatedTokenAddress: web3.PublicKey,\n  payer: web3.PublicKey,\n  walletAddress: web3.PublicKey,\n  splTokenMintAddress: web3.PublicKey\n) {\n  const keys = [\n    {\n      pubkey: payer,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: web3.SystemProgram.programId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: web3.SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  return new web3.TransactionInstruction({\n    keys,\n    programId: SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n}\n","// @ts-nocheck\nimport { web3, BN } from \"@project-serum/anchor\";\nimport { Callback } from \"./common\";\n\nexport interface AnchorMatchState {\n  draft?: boolean;\n  initialized?: boolean;\n  started?: boolean;\n  finalized?: boolean;\n  paidOut?: boolean;\n  deactivated?: boolean;\n}\n\nexport interface AnchorTokenEntryValidation {\n  filter: AnchorFilter;\n  isBlacklist: boolean;\n  validation: null | Callback;\n}\n\nexport interface AnchorFilter {\n  none?: boolean;\n  all?: boolean;\n  namespace?: { namespace: web3.PublicKey };\n  parent?: { key: web3.PublicKey };\n  mint?: { mint: web3.PublicKey };\n}\n\nexport enum MatchState {\n  Draft,\n  Initialized,\n  Started,\n  Finalized,\n  PaidOut,\n  Deactivated,\n}\n\nexport enum TokenTransferType {\n  PlayerToPlayer,\n  PlayerToEntrant,\n  Normal,\n}\n\nexport enum TokenType {\n  Player,\n  Item,\n  Any,\n}\n\nexport interface AnchorTokenTransferType {\n  playerToPlayer?: boolean;\n  playerToEntrant?: boolean;\n  normal?: boolean;\n}\nexport interface AnchorTokenDelta {\n  from: web3.PublicKey;\n  to: web3.PublicKey | null;\n  tokenTransferType: AnchorTokenTransferType;\n  mint: web3.PublicKey;\n  amount: BN;\n}\n","import { clusterApiUrl } from \"@solana/web3.js\";\n\ntype Cluster = {\n  name: string;\n  url: string;\n};\nexport const CLUSTERS: Cluster[] = [\n  {\n    name: \"mainnet-beta\",\n    url: \"https://api.metaplex.solana.com/\",\n  },\n  {\n    name: \"testnet\",\n    url: clusterApiUrl(\"testnet\"),\n  },\n  {\n    name: \"devnet\",\n    url: clusterApiUrl(\"devnet\"),\n  },\n];\nexport const DEFAULT_CLUSTER = CLUSTERS[2];\nexport function getCluster(name: string): string {\n  for (const cluster of CLUSTERS) {\n    if (cluster.name === name) {\n      return cluster.url;\n    }\n  }\n  return DEFAULT_CLUSTER.url;\n}\n","// @ts-nocheck\nimport fs from 'fs'\nimport { sendTransactionWithRetry } from '../../connection'\nimport {\n  web3,\n  Program,\n  BN,\n  \n  Provider,\n  Idl,\n} from \"@project-serum/anchor\";\nimport { PublicKey, SystemProgram } from \"@solana/web3.js\";\n\nimport NodeWallet from \"@project-serum/anchor/dist/cjs/nodewallet\";\nimport { MATCHES_ID, TOKEN_PROGRAM_ID } from \"../constants/programIds\";\nimport {\n  getAtaForMint,\n  getItemPDA,\n  getMatch,\n  getMatchTokenAccountEscrow,\n  getOracle,\n  getPlayerPDA,\n} from \"../utils/pda\";\nimport { ObjectWrapper } from \"./common\";\nimport log from \"loglevel\";\nimport { getCluster } from \"../utils/connection\";\nimport {\n  AnchorMatchState,\n  AnchorTokenDelta,\n  AnchorTokenEntryValidation,\n  TokenType,\n} from \"../state/matches\";\nimport { Token } from \"@solana/spl-token\";\nimport { createAssociatedTokenAccountInstruction } from \"../utils/ata\";\n\nexport function transformTokenValidations(args: {\n  tokenEntryValidation: AnchorTokenEntryValidation[] | null;\n}) {\n  if (args.tokenEntryValidation) {\n    args.tokenEntryValidation = args.tokenEntryValidation.map((r) => {\n      const newRFilter = { ...r.filter };\n      Object.keys(newRFilter).forEach((k) => {\n        Object.keys(newRFilter[k]).forEach((y) => {\n          if (typeof newRFilter[k][y] === \"string\") {\n            newRFilter[k][y] = new web3.PublicKey(newRFilter[k][y]);\n          }\n        });\n      });\n\n      r.filter = newRFilter;\n\n      if (r.validation) {\n        if (typeof r.validation.key === \"string\") {\n          r.validation.key = new web3.PublicKey(r.validation.key);\n          r.validation.code = new BN(r.validation.code);\n        }\n      }\n      return r;\n    });\n  }\n}\nexport class MatchWrapper implements ObjectWrapper<any, MatchesProgram> {\n  program: MatchesProgram;\n  key: web3.PublicKey;\n  object: any;\n  data: Buffer;\n\n  constructor(args: {\n    program: MatchesProgram;\n    key: web3.PublicKey;\n    object: any;\n    data: Buffer;\n  }) {\n    this.program = args.program;\n    this.key = args.key;\n    this.object = args.object;\n    this.data = args.data;\n  }\n}\n\nexport interface CreateMatchArgs {\n  matchState: AnchorMatchState;\n  tokenEntryValidationRoot: null;\n  tokenEntryValidation: null | AnchorTokenEntryValidation[];\n  winOracle: web3.PublicKey;\n  winOracleCooldown: BN;\n  authority: web3.PublicKey;\n  space: BN;\n  leaveAllowed: boolean;\n  joinAllowedDuringStart: boolean;\n  minimumAllowedEntryTime: BN | null;\n}\n\nexport interface UpdateMatchArgs {\n  matchState: AnchorMatchState;\n  tokenEntryValidationRoot: null;\n  tokenEntryValidation: null;\n  winOracleCooldown: BN;\n  authority: web3.PublicKey;\n  leaveAllowed: boolean;\n  joinAllowedDuringStart: boolean;\n  minimumAllowedEntryTime: BN | null;\n}\n\nexport interface JoinMatchArgs {\n  amount: BN;\n  tokenEntryValidationProof: null;\n  tokenEntryValidation: null;\n}\n\nexport interface LeaveMatchArgs {\n  amount: BN;\n}\n\nexport interface DisburseTokensByOracleArgs {\n  tokenDeltaProofInfo: null;\n}\n\nexport interface CreateMatchAdditionalArgs {\n  seed: string;\n  finalized: boolean;\n  tokenTransferRoot: null;\n  tokenTransfers: null | AnchorTokenDelta[];\n}\n\nexport interface CreateOrUpdateOracleArgs {\n  seed: string;\n  authority: web3.PublicKey;\n  space: BN;\n  finalized: boolean;\n  tokenTransferRoot: null;\n  tokenTransfers: null | AnchorTokenDelta[];\n}\n\nexport interface DrainMatchArgs {}\n\nexport interface DrainOracleArgs {\n  seed: string;\n  authority: web3.PublicKey;\n}\n\nexport interface UpdateMatchFromOracleAccounts {\n  winOracle: web3.PublicKey;\n}\n\nexport interface UpdateMatchAccounts {\n  winOracle: web3.PublicKey;\n}\n\nexport interface DrainMatchAccounts {\n  receiver: web3.PublicKey | null;\n}\n\nexport interface DrainOracleAccounts {\n  receiver: web3.PublicKey | null;\n}\n\nexport interface DisburseTokensByOracleAccounts {\n  winOracle: web3.PublicKey;\n}\n\nexport interface JoinMatchAccounts {\n  tokenMint: web3.PublicKey;\n  sourceTokenAccount: web3.PublicKey | null;\n  tokenTransferAuthority: web3.Keypair | null;\n  validationProgram: web3.PublicKey | null;\n}\n\nexport interface LeaveMatchAccounts {\n  tokenMint: web3.PublicKey;\n  receiver: web3.PublicKey;\n}\n\nexport interface JoinMatchAdditionalArgs {\n  sourceType: TokenType;\n  index: BN | null;\n  winOracle: web3.PublicKey;\n}\n\nexport interface LeaveMatchAdditionalArgs {\n  winOracle: web3.PublicKey;\n}\n\nexport interface DrainMatchAdditionalArgs {\n  winOracle: web3.PublicKey;\n}\n\nexport interface DisburseTokensByOracleAdditionalArgs {\n  tokenDelta: AnchorTokenDelta;\n}\n\nexport class MatchesInstruction {\n  id: web3.PublicKey;\n  program: Program;\n\n  constructor(args: { id: web3.PublicKey; program: Program }) {\n    this.id = args.id;\n    this.program = args.program;\n  }\n\n  async createMatch(\n    args: CreateMatchArgs,\n    _accounts = {},\n    _additionalArgs = {}\n  ) {\n    const [match, _matchBump] = await getMatch(args.winOracle);\n\n    transformTokenValidations(args);\n    return {\n      instructions: [\n        await this.program.methods\n          .createMatch(args)\n          .accounts({\n            matchInstance: match,\n            payer: (this.program.provider as Provider).wallet.publicKey,\n            systemProgram: SystemProgram.programId,\n            rent: web3.SYSVAR_RENT_PUBKEY,\n          })\n          .instruction(),\n      ],\n      signers: [],\n    };\n  }\n\n  async disburseTokensByOracle(\n    args: DisburseTokensByOracleArgs,\n    accounts: DisburseTokensByOracleAccounts,\n    additionalArgs: DisburseTokensByOracleAdditionalArgs\n  ) {\n    const match = (await getMatch(accounts.winOracle))[0];\n    const tfer = additionalArgs.tokenDelta;\n\n    const [tokenAccountEscrow, _escrowBump] = await getMatchTokenAccountEscrow(\n      accounts.winOracle,\n      tfer.mint,\n      tfer.from\n    );\n\n    let destinationTokenAccount = tfer.to;\n    const info = await (\n      this.program.provider as Provider\n    ).connection.getAccountInfo(destinationTokenAccount);\n\n    const instructions = [];\n\n    if (!info.owner.equals(TOKEN_PROGRAM_ID)) {\n      const destinationTokenOwner = destinationTokenAccount;\n      destinationTokenAccount = (\n        await getAtaForMint(tfer.mint, destinationTokenAccount)\n      )[0];\n\n      const exists = await (\n        this.program.provider as Provider\n      ).connection.getAccountInfo(destinationTokenAccount);\n\n      if (!exists || exists.data.length == 0) {\n        instructions.unshift(\n          createAssociatedTokenAccountInstruction(\n            destinationTokenAccount,\n            (this.program.provider as Provider).wallet.publicKey,\n            destinationTokenOwner,\n            tfer.mint\n          )\n        );\n      }\n    }\n\n    instructions.push(\n      await this.program.methods\n        .disburseTokensByOracle(args)\n        .accounts({\n          matchInstance: match,\n          tokenAccountEscrow,\n          tokenMint: tfer.mint,\n          originalSender: tfer.from,\n          destinationTokenAccount,\n          winOracle: accounts.winOracle,\n          tokenProgram: TOKEN_PROGRAM_ID,\n          systemProgram: SystemProgram.programId,\n          rent: web3.SYSVAR_RENT_PUBKEY,\n        })\n        .instruction()\n    );\n    return {\n      instructions,\n      signers: [],\n    };\n  }\n\n  async drainMatch(\n    _args: DrainMatchArgs,\n    accounts: DrainMatchAccounts,\n    additionalArgs: DrainMatchAdditionalArgs\n  ) {\n    const match = (await getMatch(additionalArgs.winOracle))[0];\n\n    return {\n      instructions: [\n        await this.program.methods\n          .drainMatch()\n          .accounts({\n            matchInstance: match,\n            authority: (this.program.provider as Provider).wallet\n              .publicKey,\n            receiver:\n              accounts.receiver ||\n              (this.program.provider as Provider).wallet.publicKey,\n          })\n          .instruction(),\n      ],\n      signers: [],\n    };\n  }\n\n  async drainOracle(\n    args: DrainOracleArgs,\n    accounts: DrainOracleAccounts,\n    _additionalArgs = {}\n  ) {\n    const [oracle, oracleBump] = await getOracle(\n      new web3.PublicKey(args.seed),\n      new web3.PublicKey(args.authority)\n    );\n\n    const [match, _matchBump] = await getMatch(oracle);\n\n    return {\n      instructions: [\n        await this.program.methods\n          .drainOracle({ ...args, seed: new web3.PublicKey(args.seed) })\n          .accounts({\n            matchInstance: match,\n            authority: (this.program.provider as Provider).wallet\n              .publicKey,\n            receiver:\n              accounts.receiver ||\n              (this.program.provider as Provider).wallet.publicKey,\n            oracle,\n          })\n          .instruction(),\n      ],\n      signers: [],\n    };\n  }\n  async updateMatch(\n    args: UpdateMatchArgs,\n    accounts: UpdateMatchAccounts,\n    _additionalArgs = {}\n  ) {\n    const match = (await getMatch(accounts.winOracle))[0];\n    transformTokenValidations(args);\n\n    return {\n      instructions: [\n        await this.program.methods\n          .updateMatch(args)\n          .accounts({\n            matchInstance: match,\n            winOracle: accounts.winOracle,\n            authority: (this.program.provider as Provider).wallet\n              .publicKey,\n          })\n          .instruction(),\n      ],\n      signers: [],\n    };\n  }\n\n  async leaveMatch(\n    args: LeaveMatchArgs,\n    accounts: LeaveMatchAccounts,\n    additionalArgs: LeaveMatchAdditionalArgs\n  ) {\n    const match = (await getMatch(additionalArgs.winOracle))[0];\n\n    const destinationTokenAccount = (\n      await getAtaForMint(accounts.tokenMint, accounts.receiver)\n    )[0];\n\n    const [tokenAccountEscrow, _escrowBump] = await getMatchTokenAccountEscrow(\n      additionalArgs.winOracle,\n      accounts.tokenMint,\n      (this.program.provider as Provider).wallet.publicKey\n    );\n\n    const signers = [];\n\n    return {\n      instructions: [\n        await this.program.methods\n          .leaveMatch(args)\n          .accounts({\n            matchInstance: match,\n            tokenAccountEscrow,\n            tokenMint: accounts.tokenMint,\n            destinationTokenAccount,\n            receiver: (this.program.provider as Provider).wallet\n              .publicKey,\n            tokenProgram: TOKEN_PROGRAM_ID,\n          })\n          .instruction(),\n      ],\n      signers,\n    };\n  }\n\n  async joinMatch(\n    args: JoinMatchArgs,\n    accounts: JoinMatchAccounts,\n    additionalArgs: JoinMatchAdditionalArgs\n  ) {\n    const match = (await getMatch(additionalArgs.winOracle))[0];\n\n    const sourceTokenAccount =\n      accounts.sourceTokenAccount ||\n      (\n        await getAtaForMint(\n          accounts.tokenMint,\n          (this.program.provider as Provider).wallet.publicKey\n        )\n      )[0];\n    const transferAuthority =\n      accounts.tokenTransferAuthority || web3.Keypair.generate();\n\n    const [tokenAccountEscrow, _escrowBump] = await getMatchTokenAccountEscrow(\n      additionalArgs.winOracle,\n      accounts.tokenMint,\n      (this.program.provider as Provider).wallet.publicKey\n    );\n\n    const signers = [transferAuthority];\n\n    return {\n      instructions: [\n        Token.createApproveInstruction(\n          TOKEN_PROGRAM_ID,\n          sourceTokenAccount,\n          transferAuthority.publicKey,\n          (this.program.provider as Provider).wallet.publicKey,\n          [],\n          args.amount.toNumber()\n        ),\n        await this.program.methods\n          .joinMatch(args)\n          .accounts({\n            matchInstance: match,\n            tokenTransferAuthority: transferAuthority.publicKey,\n            tokenAccountEscrow,\n            tokenMint: accounts.tokenMint,\n            sourceTokenAccount,\n            sourceItemOrPlayerPda:\n              additionalArgs.sourceType == TokenType.Any\n                ? SystemProgram.programId\n                : additionalArgs.sourceType == TokenType.Item\n                ? (\n                    await getItemPDA(accounts.tokenMint, additionalArgs.index)\n                  )[0]\n                : (\n                    await getPlayerPDA(accounts.tokenMint, additionalArgs.index)\n                  )[0],\n            payer: (this.program.provider as Provider).wallet.publicKey,\n            systemProgram: SystemProgram.programId,\n            validationProgram:\n              accounts.validationProgram || SystemProgram.programId,\n            tokenProgram: TOKEN_PROGRAM_ID,\n            rent: web3.SYSVAR_RENT_PUBKEY,\n          })\n          .signers(signers)\n          .instruction(),\n        Token.createRevokeInstruction(\n          TOKEN_PROGRAM_ID,\n          sourceTokenAccount,\n          (this.program.provider as Provider).wallet.publicKey,\n          []\n        ),\n      ],\n      signers,\n    };\n  }\n\n  async updateMatchFromOracle(\n    args = {},\n    accounts: UpdateMatchFromOracleAccounts,\n    _additionalArgs = {}\n  ) {\n    const match = (await getMatch(accounts.winOracle))[0];\n\n    return {\n      instructions: [\n        await this.program.methods\n          .updateMatchFromOracle()\n          .accounts({\n            matchInstance: match,\n            winOracle: accounts.winOracle,\n            authority: (this.program.provider as Provider).wallet\n              .publicKey,\n            clock: web3.SYSVAR_CLOCK_PUBKEY,\n          })\n          .instruction(),\n      ],\n      signers: [],\n    };\n  }\n\n  async createOrUpdateOracle(\n    args: CreateOrUpdateOracleArgs,\n    _accounts = {},\n    _additionalArgs = {}\n  ) {\n    const [oracle, _oracleBump] = await getOracle(\n      new web3.PublicKey(args.seed),\n      args.authority\n    );\n\n    const tokenTransfers = args.tokenTransfers\n      ? args.tokenTransfers.map((t) => ({\n          ...t,\n          from: new web3.PublicKey(t.from),\n          to: t.to ? new web3.PublicKey(t.to) : null,\n          mint: new web3.PublicKey(t.mint),\n          amount: new BN(t.amount),\n        }))\n      : null;\n\n    return {\n      instructions: [\n        await this.program.methods\n          .createOrUpdateOracle({\n            ...args,\n            tokenTransfers,\n            seed: new web3.PublicKey(args.seed),\n          })\n          .accounts({\n            oracle,\n            payer: (this.program.provider as Provider).wallet.publicKey,\n            systemProgram: SystemProgram.programId,\n            rent: web3.SYSVAR_RENT_PUBKEY,\n          })\n          .instruction(),\n      ],\n      signers: [],\n    };\n  }\n}\n\nexport class MatchesProgram {\n  id: web3.PublicKey;\n  program: Program;\n  instruction: MatchesInstruction;\n\n  constructor(args: { id: web3.PublicKey; program: Program }) {\n    this.id = args.id;\n    this.program = args.program;\n    this.instruction = new MatchesInstruction({\n      id: this.id,\n      program: this.program,\n    });\n  }\n\n  async fetchMatch(oracle: web3.PublicKey): Promise<MatchWrapper> {\n    const matchPda = (await getMatch(oracle))[0];\n\n    const match = await this.program.account.match.fetch(matchPda);\n\n    return new MatchWrapper({\n      program: this,\n      key: matchPda,\n      data: match.data as Buffer,\n      object: match,\n    });\n  }\n\n  async fetchOracle(oracle: web3.PublicKey): Promise<MatchWrapper> {\n    const oracleAcct = await (\n      this.program.provider as Provider\n    ).connection.getAccountInfo(oracle);\n\n    const oracleInstance =\n      await this.program.account.winOracle.coder.accounts.decode(\n        \"WinOracle\",\n        oracleAcct.data\n      );\n\n    return new MatchWrapper({\n      program: this,\n      key: oracle,\n      data: oracleAcct.data,\n      object: oracleInstance,\n    });\n  }\n\n  async createMatch(\n    args: CreateMatchArgs,\n    _accounts = {},\n    additionalArgs: CreateMatchAdditionalArgs\n  ) {\n    const { instructions, signers } = await this.instruction.createMatch(args);\n\n    await sendTransactionWithRetry(\n      (this.program.provider as Provider).connection,\n      (this.program.provider as Provider).wallet,\n      instructions,\n      signers\n    );\n  }\n\n  async disburseTokensByOracle(\n    args: DisburseTokensByOracleArgs,\n    accounts: DisburseTokensByOracleAccounts,\n    additionalArgs: DisburseTokensByOracleAdditionalArgs\n  ) {\n    const { instructions, signers } =\n      await this.instruction.disburseTokensByOracle(\n        args,\n        accounts,\n        additionalArgs\n      );\n\n    await sendTransactionWithRetry(\n      (this.program.provider as Provider).connection,\n      (this.program.provider as Provider).wallet,\n      instructions,\n      signers\n    );\n  }\n\n  async drainMatch(\n    args: DrainMatchArgs,\n    accounts: DrainMatchAccounts,\n    additionalArgs: DrainMatchAdditionalArgs\n  ) {\n    const { instructions, signers } = await this.instruction.drainMatch(\n      args,\n      accounts,\n      additionalArgs\n    );\n\n    await sendTransactionWithRetry(\n      (this.program.provider as Provider).connection,\n      (this.program.provider as Provider).wallet,\n      instructions,\n      signers\n    );\n  }\n\n  async drainOracle(\n    args: DrainOracleArgs,\n    accounts: DrainOracleAccounts,\n    _additionalArgs = {}\n  ) {\n    const { instructions, signers } = await this.instruction.drainOracle(\n      args,\n      accounts\n    );\n\n    await sendTransactionWithRetry(\n      (this.program.provider as Provider).connection,\n      (this.program.provider as Provider).wallet,\n      instructions,\n      signers\n    );\n  }\n\n  async joinMatch(\n    args: JoinMatchArgs,\n    accounts: JoinMatchAccounts,\n    additionalArgs: JoinMatchAdditionalArgs\n  ) {\n    const { instructions, signers } = await this.instruction.joinMatch(\n      args,\n      accounts,\n      additionalArgs\n    );\n    return { instructions, signers };\n\n /*  \n   await sendTransactionWithRetry(\n\n    (this.program.provider as Provider).connection,\n    (this.program.provider as Provider).wallet,\n    instructions,\n    signers)\n    */\n   }\n\n  async leaveMatch(\n    args: LeaveMatchArgs,\n    accounts: LeaveMatchAccounts,\n    additionalArgs: LeaveMatchAdditionalArgs\n  ) {\n    const { instructions, signers } = await this.instruction.leaveMatch(\n      args,\n      accounts,\n      additionalArgs\n    );\n\n    await sendTransactionWithRetry(\n      (this.program.provider as Provider).connection,\n      (this.program.provider as Provider).wallet,\n      instructions,\n      signers\n    );\n  }\n\n  async updateMatch(\n    args: UpdateMatchArgs,\n    accounts: UpdateMatchAccounts,\n    _additionalArgs = {}\n  ) {\n    const { instructions, signers } = await this.instruction.updateMatch(\n      args,\n      accounts\n    );\n\n    await sendTransactionWithRetry(\n      (this.program.provider as Provider).connection,\n      (this.program.provider as Provider).wallet,\n      instructions,\n      signers\n    );\n  }\n\n  async updateMatchFromOracle(\n    args = {},\n    accounts: UpdateMatchFromOracleAccounts,\n    _additionalArgs = {}\n  ) {\n    const { instructions, signers } =\n      await this.instruction.updateMatchFromOracle(args, accounts);\n\n    await sendTransactionWithRetry(\n      (this.program.provider as Provider).connection,\n      (this.program.provider as Provider).wallet,\n      instructions,\n      signers\n    );\n  }\n\n  async createOrUpdateOracle(\n    args: CreateOrUpdateOracleArgs,\n    _accounts = {},\n    _additionalArgs = {}\n  ) {\n    const { instructions, signers } =\n      await this.instruction.createOrUpdateOracle(args);\n\n    await sendTransactionWithRetry(\n      (this.program.provider as Provider).connection,\n      (this.program.provider as Provider).wallet,\n      instructions,\n      signers\n    );\n  }\n}\n\nexport async function getMatchesProgram(\n  anchorWallet: NodeWallet | web3.Keypair,\n  env: string,\n  customRpcUrl: string\n): Promise<MatchesProgram> {\n  if (customRpcUrl) log.debug(\"USING CUSTOM URL\", customRpcUrl);\n\n  const solConnection = new web3.Connection(customRpcUrl || getCluster(env));\n\n  if (anchorWallet instanceof web3.Keypair)\n    anchorWallet = new NodeWallet(anchorWallet);\n\n  const provider = new Provider(solConnection, anchorWallet, {\n    preflightCommitment: \"recent\",\n  });\n\n  const idl = await Program.fetchIdl(MATCHES_ID, provider);\nfs.writeFileSync('matchesidl.json', JSON.stringify(idl))\n  const program = new Program(idl as Idl, MATCHES_ID, provider);\n\n  return new MatchesProgram({\n    id: MATCHES_ID,\n    program,\n  });\n}\n\nexport async function getMatchesProgram2(\n  anchorWallet: NodeWallet | web3.Keypair,\n  env: string,\n  customRpcUrl: string\n): Promise<MatchesProgram> {\n  if (customRpcUrl) log.debug(\"USING CUSTOM URL\", customRpcUrl);\n\n  const solConnection = new web3.Connection(customRpcUrl || getCluster(env));\n\n  if (anchorWallet instanceof web3.Keypair)\n    anchorWallet = new NodeWallet(anchorWallet);\n  const provider = new Provider(solConnection, anchorWallet, {\n    preflightCommitment: \"recent\",\n    \n  });\n\n  const idl = await Program.fetchIdl(MATCHES_ID, provider);\n\n  const program = new Program(idl as Idl, MATCHES_ID, provider);\n\n  return new MatchesProgram({\n    id: MATCHES_ID,\n    program,\n  });\n}","import { web3, BN } from \"@project-serum/anchor\";\nimport {\n  TOKEN_PROGRAM_ID,\n  SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID,\n  NAMESPACE_ID,\n  ITEM_ID,\n  TOKEN_METADATA_PROGRAM_ID,\n  MATCHES_ID,\n  PLAYER_ID,\n} from \"../constants/programIds\";\nimport { PREFIX as ITEM_PREFIX, MARKER } from \"../constants/item\";\nimport { PREFIX as MATCHES_PREFIX } from \"../constants/matches\";\nimport { PREFIX as NAMESPACE_PREFIX } from \"../constants/namespace\";\nimport { PREFIX as PLAYER_PREFIX } from \"../constants/player\";\n\nexport const getAtaForMint = async (\n  mint: web3.PublicKey,\n  wallet: web3.PublicKey\n): Promise<[web3.PublicKey, number]> => {\n  return await web3.PublicKey.findProgramAddress(\n    [wallet.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()],\n    SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID\n  );\n};\n\nexport const getMatch = async (\n  oracle: web3.PublicKey\n): Promise<[web3.PublicKey, number]> => {\n  return await web3.PublicKey.findProgramAddress(\n    [Buffer.from(MATCHES_PREFIX), oracle.toBuffer()],\n    MATCHES_ID\n  );\n};\n\nexport const getMatchTokenAccountEscrow = async (\n  oracle: web3.PublicKey,\n  tokenMint: web3.PublicKey,\n  tokenOwner: web3.PublicKey\n): Promise<[web3.PublicKey, number]> => {\n  return await web3.PublicKey.findProgramAddress(\n    [\n      Buffer.from(MATCHES_PREFIX),\n      oracle.toBuffer(),\n      tokenMint.toBuffer(),\n      tokenOwner.toBuffer(),\n    ],\n    MATCHES_ID\n  );\n};\n\nexport const getOracle = async (\n  seed: web3.PublicKey,\n  payer: web3.PublicKey\n): Promise<[web3.PublicKey, number]> => {\n  return await web3.PublicKey.findProgramAddress(\n    [Buffer.from(MATCHES_PREFIX), payer.toBuffer(), seed.toBuffer()],\n    MATCHES_ID\n  );\n};\n\nexport const getNamespacePDA = async (\n  mint: web3.PublicKey\n): Promise<[web3.PublicKey, number]> => {\n  return await web3.PublicKey.findProgramAddress(\n    [Buffer.from(NAMESPACE_PREFIX), mint.toBuffer()],\n    NAMESPACE_ID\n  );\n};\n\nexport const getItemPDA = async (\n  mint: web3.PublicKey,\n  index: BN\n): Promise<[web3.PublicKey, number]> => {\n  console.log(index)\n  return await web3.PublicKey.findProgramAddress(\n    [Buffer.from(ITEM_PREFIX), mint.toBuffer(), Buffer.from(index)],//.toBuffer(\"le\", 8)],\n    ITEM_ID\n  );\n};\n\nexport const getPlayerPDA = async (\n  mint: web3.PublicKey,\n  index: BN\n): Promise<[web3.PublicKey, number]> => {\n  return await web3.PublicKey.findProgramAddress(\n    [Buffer.from(PLAYER_PREFIX), mint.toBuffer(), index.toBuffer(\"le\", 8)],\n    PLAYER_ID\n  );\n};\n\nexport const getItemActivationMarker = async (args: {\n  itemMint: web3.PublicKey;\n  index: BN;\n  usageIndex: BN;\n  amount: BN;\n}): Promise<[web3.PublicKey, number]> => {\n  return await web3.PublicKey.findProgramAddress(\n    [\n      Buffer.from(ITEM_PREFIX),\n      args.itemMint.toBuffer(),\n      args.index.toBuffer(\"le\", 8),\n      args.usageIndex.toBuffer(\"le\", 8),\n      args.amount.toBuffer(\"le\", 8),\n      Buffer.from(MARKER),\n    ],\n    ITEM_ID\n  );\n};\n\nexport const getCraftItemCounter = async (args: {\n  itemClassMint: web3.PublicKey;\n  newItemMint: web3.PublicKey;\n  craftItemMint: web3.PublicKey;\n  componentScope: String;\n  craftItemIndex: BN;\n  craftEscrowIndex: BN;\n  classIndex: BN;\n}): Promise<[web3.PublicKey, number]> => {\n  return await web3.PublicKey.findProgramAddress(\n    [\n      Buffer.from(ITEM_PREFIX),\n      args.itemClassMint.toBuffer(),\n      args.classIndex.toBuffer(\"le\", 8),\n      args.newItemMint.toBuffer(),\n      args.craftEscrowIndex.toBuffer(\"le\", 8),\n      args.craftItemIndex.toBuffer(\"le\", 8),\n      args.craftItemMint.toBuffer(),\n      Buffer.from(args.componentScope),\n    ],\n    ITEM_ID\n  );\n};\n\nexport const getCraftItemEscrow = async (args: {\n  itemClassMint: web3.PublicKey;\n  payer: web3.PublicKey;\n  newItemMint: web3.PublicKey;\n  craftItemToken: web3.PublicKey;\n  craftItemMint: web3.PublicKey;\n  amountToMake: BN;\n  amountToContributeFromThisContributor: BN;\n  componentScope: String;\n  craftIndex: BN;\n  classIndex: BN;\n  craftEscrowIndex: BN;\n}): Promise<[web3.PublicKey, number]> => {\n  return await web3.PublicKey.findProgramAddress(\n    [\n      Buffer.from(ITEM_PREFIX),\n      args.itemClassMint.toBuffer(),\n      args.classIndex.toBuffer(\"le\", 8),\n      args.payer.toBuffer(),\n      args.newItemMint.toBuffer(),\n      args.craftItemToken.toBuffer(),\n      args.craftEscrowIndex.toBuffer(\"le\", 8),\n      args.craftIndex.toBuffer(\"le\", 8),\n      args.craftItemMint.toBuffer(),\n      args.amountToMake.toBuffer(\"le\", 8),\n      args.amountToContributeFromThisContributor.toBuffer(\"le\", 8),\n      Buffer.from(args.componentScope),\n    ],\n    ITEM_ID\n  );\n};\n\nexport const getItemEscrow = async (args: {\n  itemClassMint: web3.PublicKey;\n  payer: web3.PublicKey;\n  newItemMint: web3.PublicKey;\n  newItemToken: web3.PublicKey;\n  amountToMake: BN;\n  componentScope: String;\n  craftEscrowIndex: BN;\n  classIndex: BN;\n}): Promise<[web3.PublicKey, number]> => {\n  return await web3.PublicKey.findProgramAddress(\n    [\n      Buffer.from(ITEM_PREFIX),\n      args.itemClassMint.toBuffer(),\n      args.classIndex.toBuffer(\"le\", 8),\n      args.payer.toBuffer(),\n      args.newItemMint.toBuffer(),\n      args.newItemToken.toBuffer(),\n      args.craftEscrowIndex.toBuffer(\"le\", 8),\n      args.amountToMake.toBuffer(\"le\", 8),\n      Buffer.from(args.componentScope),\n    ],\n    ITEM_ID\n  );\n};\n\nexport const getMetadata = async (\n  mint: web3.PublicKey\n): Promise<web3.PublicKey> => {\n  return (\n    await web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"metadata\"),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n      ],\n      TOKEN_METADATA_PROGRAM_ID\n    )\n  )[0];\n};\n\nexport const getEdition = async (\n  mint: web3.PublicKey\n): Promise<web3.PublicKey> => {\n  return (\n    await web3.PublicKey.findProgramAddress(\n      [\n        Buffer.from(\"metadata\"),\n        TOKEN_METADATA_PROGRAM_ID.toBuffer(),\n        mint.toBuffer(),\n        Buffer.from(\"edition\"),\n      ],\n      TOKEN_METADATA_PROGRAM_ID\n    )\n  )[0];\n};\n","import { createTheme, ThemeProvider } from \"@material-ui/core\";\nimport { useMemo } from \"react\";\nimport {\n    ConnectionProvider,\n    WalletProvider,\n} from \"@solana/wallet-adapter-react\";\nimport * as anchor from \"@project-serum/anchor\";\nimport { clusterApiUrl } from \"@solana/web3.js\";\nimport { WalletAdapterNetwork } from \"@solana/wallet-adapter-base\";\nimport {\n    getPhantomWallet,\n    getSlopeWallet,\n    getSolflareWallet,\n    getSolflareWebWallet,\n    getSolletWallet,\n    getSolletExtensionWallet,\n    getSolongWallet,\n    getLedgerWallet,\n    getSafePalWallet,\n} from \"@solana/wallet-adapter-wallets\";\n\nimport {\n    WalletModalProvider\n} from '@solana/wallet-adapter-react-ui';\n\nimport \"./App.css\";\nimport { DEFAULT_TIMEOUT } from './connection';\nimport Home from \"./Home\";\n\nrequire('@solana/wallet-adapter-react-ui/styles.css');\n\nconst network = process.env.REACT_APP_SOLANA_NETWORK as WalletAdapterNetwork;\n\nconst rpcHost = process.env.REACT_APP_SOLANA_RPC_HOST!;\nconst connection = new anchor.web3.Connection(\n    rpcHost ? rpcHost : anchor.web3.clusterApiUrl('devnet'),\n);\n\nconst theme = createTheme({\n    palette: {\n        type: 'dark',\n    },\n    overrides: {\n        MuiButtonBase: {\n            root: {\n                justifyContent: 'flex-start',\n            },\n        },\n        MuiButton: {\n            root: {\n                textTransform: undefined,\n                padding: '12px 16px',\n            },\n            startIcon: {\n                marginRight: 8,\n            },\n            endIcon: {\n                marginLeft: 8,\n            },\n        },\n    },\n});\n\nconst App = () => {\n    // Custom RPC endpoint.\n  const endpoint = useMemo(() => clusterApiUrl(network), []);\n\n    // @solana/wallet-adapter-wallets includes all the adapters but supports tree shaking and lazy loading --\n    // Only the wallets you configure here will be compiled into your application, and only the dependencies\n    // of wallets that your users connect to will be loaded.\n    const wallets = useMemo(\n        () => [\n            getPhantomWallet(),\n            getSlopeWallet(),\n            getSolflareWallet(),\n            getSolflareWebWallet(),\n            getSolletWallet({ network }),\n            getSolletExtensionWallet({ network }),\n            getSolongWallet(),\n            getLedgerWallet(),\n            getSafePalWallet(),\n        ],\n        []\n    );\n\n  return (\n      <ThemeProvider theme={theme}>\n        <ConnectionProvider endpoint={endpoint}>\n          <WalletProvider wallets={wallets} autoConnect={true}>\n            <WalletModalProvider>\n              <Home\n                connection={connection}\n                txTimeout={DEFAULT_TIMEOUT}\n                rpcHost={rpcHost}\n                network={network}\n              />\n            </WalletModalProvider>\n          </WalletProvider>\n        </ConnectionProvider>\n      </ThemeProvider>\n  );\n};\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n","import {\n  Keypair,\n  Commitment,\n  Connection,\n  RpcResponseAndContext,\n  SignatureStatus,\n  SimulatedTransactionResponse,\n  Transaction,\n  TransactionInstruction,\n  TransactionSignature,\n  Blockhash,\n  FeeCalculator,\n} from '@solana/web3.js';\n\nimport { WalletNotConnectedError } from '@solana/wallet-adapter-base';\n\ninterface BlockhashAndFeeCalculator {\n  blockhash: Blockhash;\n  feeCalculator: FeeCalculator;\n}\n\nexport const DEFAULT_TIMEOUT = 60000;\n\nexport const getErrorForTransaction = async (\n    connection: Connection,\n    txid: string,\n) => {\n  // wait for all confirmation before geting transaction\n  await connection.confirmTransaction(txid, 'max');\n\n  const tx = await connection.getParsedConfirmedTransaction(txid);\n\n  const errors: string[] = [];\n  if (tx?.meta && tx.meta.logMessages) {\n    tx.meta.logMessages.forEach(log => {\n      const regex = /Error: (.*)/gm;\n      let m;\n      while ((m = regex.exec(log)) !== null) {\n        // This is necessary to avoid infinite loops with zero-width matches\n        if (m.index === regex.lastIndex) {\n          regex.lastIndex++;\n        }\n\n        if (m.length > 1) {\n          errors.push(m[1]);\n        }\n      }\n    });\n  }\n\n  return errors;\n};\n\nexport enum SequenceType {\n  Sequential,\n  Parallel,\n  StopOnFailure,\n}\n\nexport async function sendTransactionsWithManualRetry(\n    connection: Connection,\n    wallet: any,\n    instructions: TransactionInstruction[][],\n    signers: Keypair[][],\n): Promise<(string | undefined)[]> {\n  let stopPoint = 0;\n  let tries = 0;\n  let lastInstructionsLength = null;\n  let toRemoveSigners: Record<number, boolean> = {};\n  instructions = instructions.filter((instr, i) => {\n    if (instr.length > 0) {\n      return true;\n    } else {\n      toRemoveSigners[i] = true;\n      return false;\n    }\n  });\n  let ids: string[] = [];\n  let filteredSigners = signers.filter((_, i) => !toRemoveSigners[i]);\n\n  while (stopPoint < instructions.length && tries < 3) {\n    instructions = instructions.slice(stopPoint, instructions.length);\n    filteredSigners = filteredSigners.slice(stopPoint, filteredSigners.length);\n\n    if (instructions.length === lastInstructionsLength) tries = tries + 1;\n    else tries = 0;\n\n    try {\n      if (instructions.length === 1) {\n        const id = await sendTransactionWithRetry(\n            connection,\n            wallet,\n            instructions[0],\n            filteredSigners[0],\n            'single',\n        );\n        ids.push(id.txid);\n        stopPoint = 1;\n      } else {\n        const { txs } = await sendTransactions(\n            connection,\n            wallet,\n            instructions,\n            filteredSigners,\n            SequenceType.StopOnFailure,\n            'single',\n        );\n        ids = ids.concat(txs.map(t => t.txid));\n      }\n    } catch (e) {\n      console.error(e);\n    }\n    console.log(\n        'Died on ',\n        stopPoint,\n        'retrying from instruction',\n        instructions[stopPoint],\n        'instructions length is',\n        instructions.length,\n    );\n    lastInstructionsLength = instructions.length;\n  }\n\n  return ids;\n}\n\nexport const sendTransactions = async (\n    connection: Connection,\n    wallet: any,\n    instructionSet: TransactionInstruction[][],\n    signersSet: Keypair[][],\n    sequenceType: SequenceType = SequenceType.Parallel,\n    commitment: Commitment = 'singleGossip',\n    successCallback: (txid: string, ind: number) => void = (txid, ind) => {},\n    failCallback: (reason: string, ind: number) => boolean = (txid, ind) => false,\n    block?: BlockhashAndFeeCalculator,\n    beforeTransactions: Transaction[] = [],\n    afterTransactions: Transaction[] = [],\n): Promise<{ number: number; txs: { txid: string; slot: number }[] }> => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  const unsignedTxns: Transaction[] = beforeTransactions;\n\n  if (!block) {\n    block = await connection.getRecentBlockhash(commitment);\n  }\n\n  for (let i = 0; i < instructionSet.length; i++) {\n    const instructions = instructionSet[i];\n    const signers = signersSet[i];\n\n    if (instructions.length === 0) {\n      continue;\n    }\n\n    let transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = block.blockhash;\n    transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n    );\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n\n    unsignedTxns.push(transaction);\n  }\n  unsignedTxns.push(...afterTransactions);\n\n  const partiallySignedTransactions = unsignedTxns.filter(t =>\n      t.signatures.find(sig => sig.publicKey.equals(wallet.publicKey)),\n  );\n  const fullySignedTransactions = unsignedTxns.filter(\n      t => !t.signatures.find(sig => sig.publicKey.equals(wallet.publicKey)),\n  );\n  let signedTxns = await wallet.signAllTransactions(\n      partiallySignedTransactions,\n  );\n  signedTxns = fullySignedTransactions.concat(signedTxns);\n  const pendingTxns: Promise<{ txid: string; slot: number }>[] = [];\n\n  console.log(\n      'Signed txns length',\n      signedTxns.length,\n      'vs handed in length',\n      instructionSet.length,\n  );\n  for (let i = 0; i < signedTxns.length; i++) {\n    const signedTxnPromise = sendSignedTransaction({\n      connection,\n      signedTransaction: signedTxns[i],\n    });\n\n    if (sequenceType !== SequenceType.Parallel) {\n      try {\n        await signedTxnPromise.then(({ txid, slot }) =>\n            successCallback(txid, i),\n        );\n        pendingTxns.push(signedTxnPromise);\n      } catch (e) {\n        console.log('Failed at txn index:', i);\n        console.log('Caught failure:', e);\n\n        failCallback(signedTxns[i], i);\n        if (sequenceType === SequenceType.StopOnFailure) {\n          return {\n            number: i,\n            txs: await Promise.all(pendingTxns),\n          };\n        }\n      }\n    } else {\n      pendingTxns.push(signedTxnPromise);\n    }\n  }\n\n  if (sequenceType !== SequenceType.Parallel) {\n    const result = await Promise.all(pendingTxns);\n    return { number: signedTxns.length, txs: result };\n  }\n\n  return { number: signedTxns.length, txs: await Promise.all(pendingTxns) };\n};\n\nexport const sendTransaction = async (\n    connection: Connection,\n    wallet: any,\n    instructions: TransactionInstruction[] | Transaction,\n    signers: Keypair[],\n    awaitConfirmation = true,\n    commitment: Commitment = 'singleGossip',\n    includesFeePayer: boolean = false,\n    block?: BlockhashAndFeeCalculator,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction: Transaction;\n  if (instructions instanceof Transaction) {\n    transaction = instructions;\n  } else {\n    transaction = new Transaction();\n    instructions.forEach(instruction => transaction.add(instruction));\n    transaction.recentBlockhash = (\n        block || (await connection.getRecentBlockhash(commitment))\n    ).blockhash;\n\n    if (includesFeePayer) {\n      transaction.setSigners(...signers.map(s => s.publicKey));\n    } else {\n      transaction.setSigners(\n          // fee payed by the wallet owner\n          wallet.publicKey,\n          ...signers.map(s => s.publicKey),\n      );\n    }\n\n    if (signers.length > 0) {\n      transaction.partialSign(...signers);\n    }\n    if (!includesFeePayer) {\n      transaction = await wallet.signTransaction(transaction);\n    }\n  }\n\n  const rawTransaction = transaction.serialize();\n  let options = {\n    skipPreflight: true,\n    commitment,\n  };\n\n  const txid = await connection.sendRawTransaction(rawTransaction, options);\n  let slot = 0;\n\n  if (awaitConfirmation) {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n        txid,\n        DEFAULT_TIMEOUT,\n        connection,\n        commitment,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n    slot = confirmation?.slot || 0;\n\n    if (confirmation?.err) {\n      const errors = await getErrorForTransaction(connection, txid);\n\n      console.log(errors);\n      throw new Error(`Raw transaction ${txid} failed`);\n    }\n  }\n\n  return { txid, slot };\n};\n\nexport const sendTransactionWithRetry = async (\n    connection: Connection,\n    wallet: any,\n    instructions: TransactionInstruction[],\n    signers: Keypair[],\n    commitment: Commitment = 'singleGossip',\n    includesFeePayer: boolean = false,\n    block?: BlockhashAndFeeCalculator,\n    beforeSend?: () => void,\n) => {\n  if (!wallet.publicKey) throw new WalletNotConnectedError();\n\n  let transaction = new Transaction();\n  instructions.forEach(instruction => transaction.add(instruction));\n  transaction.recentBlockhash = (\n      block || (await connection.getRecentBlockhash(commitment))\n  ).blockhash;\n\n  if (includesFeePayer) {\n    transaction.setSigners(...signers.map(s => s.publicKey));\n  } else {\n    transaction.setSigners(\n        // fee payed by the wallet owner\n        wallet.publicKey,\n        ...signers.map(s => s.publicKey),\n    );\n  }\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n  if (!includesFeePayer) {\n    transaction = await wallet.signTransaction(transaction);\n  }\n\n  if (beforeSend) {\n    beforeSend();\n  }\n\n  const { txid, slot } = await sendSignedTransaction({\n    connection,\n    signedTransaction: transaction,\n  });\n\n  return { txid, slot };\n};\n\nexport const getUnixTs = () => {\n  return new Date().getTime() / 1000;\n};\n\nexport async function sendSignedTransaction({\n                                              signedTransaction,\n                                              connection,\n                                              timeout = DEFAULT_TIMEOUT,\n                                            }: {\n  signedTransaction: Transaction;\n  connection: Connection;\n  sendingMessage?: string;\n  sentMessage?: string;\n  successMessage?: string;\n  timeout?: number;\n}): Promise<{ txid: string; slot: number }> {\n  const rawTransaction = signedTransaction.serialize();\n\n  const startTime = getUnixTs();\n  let slot = 0;\n  const txid: TransactionSignature = await connection.sendRawTransaction(\n      rawTransaction,\n      {\n        skipPreflight: true,\n      },\n  );\n\n  console.log('Started awaiting confirmation for', txid);\n\n  let done = false;\n  (async () => {\n    while (!done && getUnixTs() - startTime < timeout) {\n      connection.sendRawTransaction(rawTransaction, {\n        skipPreflight: true,\n      });\n      await sleep(500);\n    }\n  })();\n  try {\n    const confirmation = await awaitTransactionSignatureConfirmation(\n        txid,\n        timeout,\n        connection,\n        'recent',\n        true,\n    );\n\n    if (!confirmation)\n      throw new Error('Timed out awaiting confirmation on transaction');\n\n    if (confirmation.err) {\n      console.error(confirmation.err);\n      throw new Error('Transaction failed: Custom instruction error');\n    }\n\n    slot = confirmation?.slot || 0;\n  } catch (err: any) {\n    console.error('Timeout Error caught', err);\n    if (err.timeout) {\n      throw new Error('Timed out awaiting confirmation on transaction');\n    }\n    let simulateResult: SimulatedTransactionResponse | null = null;\n    try {\n      simulateResult = (\n          await simulateTransaction(connection, signedTransaction, 'single')\n      ).value;\n    } catch (e) {}\n    if (simulateResult && simulateResult.err) {\n      if (simulateResult.logs) {\n        for (let i = simulateResult.logs.length - 1; i >= 0; --i) {\n          const line = simulateResult.logs[i];\n          if (line.startsWith('Program log: ')) {\n            throw new Error(\n                'Transaction failed: ' + line.slice('Program log: '.length),\n            );\n          }\n        }\n      }\n      throw new Error(JSON.stringify(simulateResult.err));\n    }\n    // throw new Error('Transaction failed');\n  } finally {\n    done = true;\n  }\n\n  console.log('Latency', txid, getUnixTs() - startTime);\n  return { txid, slot };\n}\n\nasync function simulateTransaction(\n    connection: Connection,\n    transaction: Transaction,\n    commitment: Commitment,\n): Promise<RpcResponseAndContext<SimulatedTransactionResponse>> {\n  // @ts-ignore\n  transaction.recentBlockhash = await connection._recentBlockhash(\n      // @ts-ignore\n      connection._disableBlockhashCaching,\n  );\n\n  const signData = transaction.serializeMessage();\n  // @ts-ignore\n  const wireTransaction = transaction._serialize(signData);\n  const encodedTransaction = wireTransaction.toString('base64');\n  const config: any = { encoding: 'base64', commitment };\n  const args = [encodedTransaction, config];\n\n  // @ts-ignore\n  const res = await connection._rpcRequest('simulateTransaction', args);\n  if (res.error) {\n    throw new Error('failed to simulate transaction: ' + res.error.message);\n  }\n  return res.result;\n}\n\nasync function awaitTransactionSignatureConfirmation(\n    txid: TransactionSignature,\n    timeout: number,\n    connection: Connection,\n    commitment: Commitment = 'recent',\n    queryStatus = false,\n): Promise<SignatureStatus | null | void> {\n  let done = false;\n  let status: SignatureStatus | null | void = {\n    slot: 0,\n    confirmations: 0,\n    err: null,\n  };\n  let subId = 0;\n  status = await new Promise(async (resolve, reject) => {\n    setTimeout(() => {\n      if (done) {\n        return;\n      }\n      done = true;\n      console.log('Rejecting for timeout...');\n      reject({ timeout: true });\n    }, timeout);\n    try {\n      subId = connection.onSignature(\n          txid,\n          (result, context) => {\n            done = true;\n            status = {\n              err: result.err,\n              slot: context.slot,\n              confirmations: 0,\n            };\n            if (result.err) {\n              console.log('Rejected via websocket', result.err);\n              reject(status);\n            } else {\n              console.log('Resolved via websocket', result);\n              resolve(status);\n            }\n          },\n          commitment,\n      );\n    } catch (e) {\n      done = true;\n      console.error('WS error in setup', txid, e);\n    }\n    while (!done && queryStatus) {\n      // eslint-disable-next-line no-loop-func\n      (async () => {\n        try {\n          const signatureStatuses = await connection.getSignatureStatuses([\n            txid,\n          ]);\n          status = signatureStatuses && signatureStatuses.value[0];\n          if (!done) {\n            if (!status) {\n              console.log('REST null result for', txid, status);\n            } else if (status.err) {\n              console.log('REST error for', txid, status);\n              done = true;\n              reject(status.err);\n            } else if (!status.confirmations) {\n              console.log('REST no confirmations for', txid, status);\n            } else {\n              console.log('REST confirmation for', txid, status);\n              done = true;\n              resolve(status);\n            }\n          }\n        } catch (e) {\n          if (!done) {\n            console.log('REST connection error: txid', txid, e);\n          }\n        }\n      })();\n      await sleep(2000);\n    }\n  });\n\n  //@ts-ignore\n  if (connection._signatureSubscriptions[subId])\n    connection.removeSignatureListener(subId);\n  done = true;\n  console.log('Returning status', status);\n  return status;\n}\nexport function sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n"],"sourceRoot":""}